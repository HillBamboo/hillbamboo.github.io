<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>algos on hill&#39;s blog</title>
    <link>https://hillbamboo.github.io/tags/algos/</link>
    <description>Recent content in algos on hill&#39;s blog</description>
    <image>
      <title>hill&#39;s blog</title>
      <url>https://hillbamboo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://hillbamboo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 28 Mar 2021 16:28:26 +0000</lastBuildDate><atom:link href="https://hillbamboo.github.io/tags/algos/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Leetcode每日打卡]二叉搜索树迭代器</title>
      <link>https://hillbamboo.github.io/posts/tech/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Sun, 28 Mar 2021 16:28:26 +0000</pubDate>
      
      <guid>https://hillbamboo.github.io/posts/tech/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>原题描述 二叉搜索树迭代器
思路 模拟法。 用O(n)空间的数组保存中序遍历的结果，使用指针start保存当前迭代器所处的下标。
class BSTIterator { public: vector&amp;lt;int&amp;gt; vals; int len = 0; int start = -1; void _build(TreeNode* root) { if (!root) return; if (root-&amp;gt;left) _build(root-&amp;gt;left); vals.push_back(root-&amp;gt;val); ++len; if (root-&amp;gt;right) _build(root-&amp;gt;right); } BSTIterator(TreeNode* root) { _build(root); } int next() { return vals[++start]; } bool hasNext() { return start + 1 &amp;lt; len; } }; 运行结果 执行用时：28 ms, 击败 91.85% 的用户 内存消耗：23.6 MB，超过 45.59% 的用户 </description>
    </item>
    
    <item>
      <title>[Leetcode每日打卡]旋转链表</title>
      <link>https://hillbamboo.github.io/posts/tech/leetcode-daily-001/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hillbamboo.github.io/posts/tech/leetcode-daily-001/</guid>
      <description>原题描述 旋转链表
思路 简单题，可使用模拟法。注意处理空链表、k &amp;gt;=链表长度len等边界情况
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { ListNode* cur = head; if (cur == nullptr) return 0; int len = 0; while (cur) ++len, cur = cur-&amp;gt;next; int first = (len - (k % len)) % len; if (first == 0) return head; cur = head; for (int i = 0; i &amp;lt; first - 1; ++i) { cur = cur-&amp;gt;next; } ListNode* last = cur-&amp;gt;next; cur-&amp;gt;next = nullptr; ListNode* ans = last; while (last-&amp;gt;next) last = last-&amp;gt;next; last-&amp;gt;next = head; return ans; } }; 运行结果 执行用时：8 ms, 击败82.17%的用户 内存消耗：11.4 MB，超过44.80%的用户 </description>
    </item>
    
  </channel>
</rss>
