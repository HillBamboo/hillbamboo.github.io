[{"content":"问题定义 给定数组arr，长度T，其中某些arr[i]到arr[j]存在转移概率，将arr分成k组，使得arr的整体分组和最大。 对于arr的每一个子数组arr[i..j]，其分组值定义为 arr[i]到arr[j]的转移概率 arr的分组和是其每一个子数组的分组值之和\n问题求解 正向定义 定义数据g[i]为arr[0..i]的最大分组和 在g[j], 0 \u0026lt;= j \u0026lt; i已知的前提下，将 arr[j .. i] 分成一组，则g[i] = g[j] + trans[j, i] ，所以 $$g[i] = max(g[j] + trans(j, i)), 0 \\le j \u0026lt; i$$ g[T - 1]即为所求。\n反向定义 定义数据g[i]为arr[i..T-1]的最大分组和，其余定义与正向定义类似\n说明 jieba/init.py中的Tokenizer.calc与wordseg/ViterbiCWS.py中的ViterbiSearch的实现是等价的，均可实现序列的最大分组，不同点在于\n DAG的定义不同 如对于句子\u0026quot;学生会主动完成作业\u0026quot;，  {0: [0, 1, 2], 1: [1], 2: [2, 3], 3: [3, 4], 4: [4], 5: [5, 6], 6: [6], 7: [7, 8], 8: [8]} # jieba {0: [0], 1: [0, 1], 2: [0, 2], 3: [3], 4: [3, 4], 5: [5], 6: [5, 6], 7: [7], 8: [7, 8]} # ViterbiSearch 用于实现DP的状态定义不同 jieba使用的正向定义，ViterbiSearch使用的是反向定义  代码实现 使用反向定义，实现逻辑与ViterbiSearch一致。 可以尝试提升“学生会”的词频，使得cut能且分出“学生会”。 或者提升 长江大桥 的词频，使得cut能切分出 “长江大桥”\nfreq = { \u0026#34;学生\u0026#34;: 400, \u0026#34;学生会\u0026#34;: 20, \u0026#34;完成\u0026#34;: 500, \u0026#34;作业\u0026#34;: 300, \u0026#34;主动\u0026#34;: 400, \u0026#34;学\u0026#34;: 10, \u0026#34;生\u0026#34;: 10, \u0026#34;会\u0026#34;: 20, \u0026#34;主\u0026#34;: 50, \u0026#34;动\u0026#34;: 10, \u0026#34;完\u0026#34;: 100, \u0026#34;成\u0026#34;: 55, \u0026#34;作\u0026#34;: 40, \u0026#34;业\u0026#34;: 5, \u0026#34;大桥\u0026#34;: 20, \u0026#34;南京\u0026#34;: 60, \u0026#34;南京市\u0026#34;: 30, \u0026#34;市长\u0026#34;: 40, \u0026#34;江大桥\u0026#34;: 888, \u0026#34;长江大桥\u0026#34;: 666, \u0026#34;南\u0026#34;: 10, \u0026#34;京\u0026#34;: 40, \u0026#34;市\u0026#34;: 6, \u0026#34;长\u0026#34;: 7, \u0026#34;江\u0026#34;: 50, \u0026#34;大\u0026#34;: 5, \u0026#34;桥\u0026#34;: 40, } total = 3000 def build_dag(sentence: str) -\u0026gt; dict: \u0026#34;\u0026#34;\u0026#34; 构建以每个token结尾的有向词图 如 \u0026#34;学生会主动完成作业\u0026#34; =\u0026gt; {0: [0], 1: [0, 1], 2: [0, 2], 3: [3], 4: [3, 4], 5: [5], 6: [5, 6], 7: [7], 8: [7, 8]} :param sentence: :return: \u0026#34;\u0026#34;\u0026#34; n = len(sentence) dag = { i: [j for j in range(i + 1) if freq.get(sentence[j:i + 1], 0)] for i in range(n) } return dag def route(sentence: str, dag: dict): \u0026#34;\u0026#34;\u0026#34; g[i] = (prob, j)，prob为sentence[0..i]的最大分组和，j为sentence[i]所属的分组起始位置 g[i].prob = max(g[j] + trans(j, i)), 0 \u0026lt;= j \u0026lt; i g[i].j = argmax max(g[j] + trans(j, i)), 0 \u0026lt;= j \u0026lt; i :param sentence: :param dag: :return: \u0026#34;\u0026#34;\u0026#34; n = len(sentence) g = {-1: (0, 0)} logtotal = math.log(total) for idx in range(n): g[idx] = max( ( g[idx - 1][0] + math.log(freq.get(sentence[x: idx + 1]) or 1) - logtotal, x ) for x in dag[idx] ) return g def cut(sentence: str): dag = build_dag(sentence) g = route(sentence, dag) n = len(sentence) segments = deque() idx = n - 1 while idx \u0026gt;= 0: prev = g[idx][1] segments.appendleft(sentence[prev: idx + 1]) idx = prev - 1 return segments if __name__ == \u0026#39;__main__\u0026#39;: sents = [ \u0026#34;学生会主动完成作业\u0026#34;, \u0026#34;南京市长江大桥\u0026#34; ] for sent in sents: print(\u0026#34;%s=\u0026gt; %s\u0026#34; % (sent, \u0026#34;/\u0026#34;.join(cut(sent)))) # 学生会主动完成作业 =\u0026gt; 学生/会/主动/完成/作业 # 南京市长江大桥 =\u0026gt; 南京/市长/江大桥 ","permalink":"https://hillbamboo.github.io/posts/tech/%E5%9F%BA%E4%BA%8E%E8%AF%8D%E9%A2%91%E7%9A%84%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/","summary":"问题定义 给定数组arr，长度T，其中某些arr[i]到arr[j]存在转移概率，将arr分成k组，使得arr的整体分组和最大。 对于arr的每一个子数组arr[i..j]，其分组值定义为 arr[i]到arr[j]的转移概率 arr的分组和是其每一个子数组的分组值之和\n问题求解 正向定义 定义数据g[i]为arr[0..i]的最大分组和 在g[j], 0 \u0026lt;= j \u0026lt; i已知的前提下，将 arr[j .. i] 分成一组，则g[i] = g[j] + trans[j, i] ，所以 $$g[i] = max(g[j] + trans(j, i)), 0 \\le j \u0026lt; i$$ g[T - 1]即为所求。\n反向定义 定义数据g[i]为arr[i..T-1]的最大分组和，其余定义与正向定义类似\n说明 jieba/init.py中的Tokenizer.calc与wordseg/ViterbiCWS.py中的ViterbiSearch的实现是等价的，均可实现序列的最大分组，不同点在于\n DAG的定义不同 如对于句子\u0026quot;学生会主动完成作业\u0026quot;，  {0: [0, 1, 2], 1: [1], 2: [2, 3], 3: [3, 4], 4: [4], 5: [5, 6], 6: [6], 7: [7, 8], 8: [8]} # jieba {0: [0], 1: [0, 1], 2: [0, 2], 3: [3], 4: [3, 4], 5: [5], 6: [5, 6], 7: [7], 8: [7, 8]} # ViterbiSearch 用于实现DP的状态定义不同 jieba使用的正向定义，ViterbiSearch使用的是反向定义  代码实现 使用反向定义，实现逻辑与ViterbiSearch一致。 可以尝试提升“学生会”的词频，使得cut能且分出“学生会”。 或者提升 长江大桥 的词频，使得cut能切分出 “长江大桥”\nfreq = { \u0026#34;学生\u0026#34;: 400, \u0026#34;学生会\u0026#34;: 20, \u0026#34;完成\u0026#34;: 500, \u0026#34;作业\u0026#34;: 300, \u0026#34;主动\u0026#34;: 400, \u0026#34;学\u0026#34;: 10, \u0026#34;生\u0026#34;: 10, \u0026#34;会\u0026#34;: 20, \u0026#34;主\u0026#34;: 50, \u0026#34;动\u0026#34;: 10, \u0026#34;完\u0026#34;: 100, \u0026#34;成\u0026#34;: 55, \u0026#34;作\u0026#34;: 40, \u0026#34;业\u0026#34;: 5, \u0026#34;大桥\u0026#34;: 20, \u0026#34;南京\u0026#34;: 60, \u0026#34;南京市\u0026#34;: 30, \u0026#34;市长\u0026#34;: 40, \u0026#34;江大桥\u0026#34;: 888, \u0026#34;长江大桥\u0026#34;: 666, \u0026#34;南\u0026#34;: 10, \u0026#34;京\u0026#34;: 40, \u0026#34;市\u0026#34;: 6, \u0026#34;长\u0026#34;: 7, \u0026#34;江\u0026#34;: 50, \u0026#34;大\u0026#34;: 5, \u0026#34;桥\u0026#34;: 40, } total = 3000 def build_dag(sentence: str) -\u0026gt; dict: \u0026#34;\u0026#34;\u0026#34; 构建以每个token结尾的有向词图 如 \u0026#34;学生会主动完成作业\u0026#34; =\u0026gt; {0: [0], 1: [0, 1], 2: [0, 2], 3: [3], 4: [3, 4], 5: [5], 6: [5, 6], 7: [7], 8: [7, 8]} :param sentence: :return: \u0026#34;\u0026#34;\u0026#34; n = len(sentence) dag = { i: [j for j in range(i + 1) if freq.","title":"基于词频的中文分词"},{"content":"原题描述 二叉搜索树迭代器\n思路 模拟法。 用O(n)空间的数组保存中序遍历的结果，使用指针start保存当前迭代器所处的下标。\nclass BSTIterator { public: vector\u0026lt;int\u0026gt; vals; int len = 0; int start = -1; void _build(TreeNode* root) { if (!root) return; if (root-\u0026gt;left) _build(root-\u0026gt;left); vals.push_back(root-\u0026gt;val); ++len; if (root-\u0026gt;right) _build(root-\u0026gt;right); } BSTIterator(TreeNode* root) { _build(root); } int next() { return vals[++start]; } bool hasNext() { return start + 1 \u0026lt; len; } }; 运行结果 执行用时：28 ms, 击败 91.85% 的用户 内存消耗：23.6 MB，超过 45.59% 的用户 ","permalink":"https://hillbamboo.github.io/posts/tech/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/","summary":"原题描述 二叉搜索树迭代器\n思路 模拟法。 用O(n)空间的数组保存中序遍历的结果，使用指针start保存当前迭代器所处的下标。\nclass BSTIterator { public: vector\u0026lt;int\u0026gt; vals; int len = 0; int start = -1; void _build(TreeNode* root) { if (!root) return; if (root-\u0026gt;left) _build(root-\u0026gt;left); vals.push_back(root-\u0026gt;val); ++len; if (root-\u0026gt;right) _build(root-\u0026gt;right); } BSTIterator(TreeNode* root) { _build(root); } int next() { return vals[++start]; } bool hasNext() { return start + 1 \u0026lt; len; } }; 运行结果 执行用时：28 ms, 击败 91.85% 的用户 内存消耗：23.6 MB，超过 45.59% 的用户 ","title":"[Leetcode每日打卡]二叉搜索树迭代器"},{"content":"为什么要进行多线程编程 无他，更快。\n多线程编程中的难点 在多线程编程环境下，计算顺序的不确定性是一个本质问题。而多线程编程的难点在于\n 线程互斥。解决数据争用的问题。多线程编程下（同一进程的）各线程共享的全局对象，由于操作系的抢占式任务调度调度方式会造成计算顺序的混乱，具体来说就是实际运行顺序并不是程序所期待的顺序。 线程同步。将一个大任务拆分为多个小任务（线程）后，小任务之间是需要通过某种方式组织起来还原会大任务的。具体来说，小任务之间是通过一个有向无环图组织起来的，其中某些小任务需要等待另外一些小任务的完成，否则无法继续。  如何解决线程互斥问题 在C++中，解决线程互斥（问题1）的方式有：\n lock_gurad/unique_lock + mutex semaphore = mutex + condition_variable + int_cnt atomic  解决问题2的方式有：\n condition_variable  解决数据争用问题 加锁操作 使用lock_gurad/unique_lock + mutex可实现异常安全的加锁操作。\n单纯使用mutex的.lock()和.unlock()方法不是异常安全的。如每一个线程要完成run()这样一个计算任务：\nmutex m; void run(int a, int b, int c) { m.lock(); int d = a + b / c; m.unlock(); } 这里使用的.lock()与.unlock()划定了一个临界区。若临界区中的计算抛异常了，就无法执行.unlock()语句。从而，mutex永远被锁上了。\n上述问题的解决知道就是使用RAII手法，利用lock_guard/unique_lock持有mutex对象。lock_guard中的构造函数调用了.lock()，析构函数实现了.unlock()，从而使用lock_guard/unique_lock + mutex可实现异常安全的锁操作。具体代码如下：\nmutex m; void run(int a, int b, int c) { lock_guard\u0026lt;mutex\u0026gt; l(m) int d = a + b / c; } 跨线程安全的资源计数 信号量实现了这样的功能：\n 获得一个资源，资源计数器减1 释放一个资源，资源计数器加1 没有资源可以获得，线程阻塞等待  C++原生不支持信号量，可以通过lock_guard/unique_lock + mutex + int_cnt手动实现一个。具体代码如下：\nclass Semaphore { private: mutex mMutex; condition_variable mCondVar; int64_t mAvailable; public: explicit Semaphore(int64_t init) : mAvailable(init) {} void post() { { unique_lock\u0026lt;mutex\u0026gt; l(mMutex); // do computation  ++mAvailable; } mCondVar.notify_one(); } void wait() { unique_lock\u0026lt;mutex\u0026gt; l(mMutex); while (mAvailable == 0) { mCondVar.wait(l); } --mAvailable; } }; 原子操作 c++的标准库atomic可实现原子操作。 todo\n解决线程等待问题 todo\nC++高级线程同步原语 future，promise，packaged_task\nfuture实现延迟计算。特别地，future可实现线程通知。\nTODO\n参考资料 10分钟，带你掌握C++多线程同步！\n","permalink":"https://hillbamboo.github.io/posts/tech/cxx-thread-sync/","summary":"为什么要进行多线程编程 无他，更快。\n多线程编程中的难点 在多线程编程环境下，计算顺序的不确定性是一个本质问题。而多线程编程的难点在于\n 线程互斥。解决数据争用的问题。多线程编程下（同一进程的）各线程共享的全局对象，由于操作系的抢占式任务调度调度方式会造成计算顺序的混乱，具体来说就是实际运行顺序并不是程序所期待的顺序。 线程同步。将一个大任务拆分为多个小任务（线程）后，小任务之间是需要通过某种方式组织起来还原会大任务的。具体来说，小任务之间是通过一个有向无环图组织起来的，其中某些小任务需要等待另外一些小任务的完成，否则无法继续。  如何解决线程互斥问题 在C++中，解决线程互斥（问题1）的方式有：\n lock_gurad/unique_lock + mutex semaphore = mutex + condition_variable + int_cnt atomic  解决问题2的方式有：\n condition_variable  解决数据争用问题 加锁操作 使用lock_gurad/unique_lock + mutex可实现异常安全的加锁操作。\n单纯使用mutex的.lock()和.unlock()方法不是异常安全的。如每一个线程要完成run()这样一个计算任务：\nmutex m; void run(int a, int b, int c) { m.lock(); int d = a + b / c; m.unlock(); } 这里使用的.lock()与.unlock()划定了一个临界区。若临界区中的计算抛异常了，就无法执行.unlock()语句。从而，mutex永远被锁上了。\n上述问题的解决知道就是使用RAII手法，利用lock_guard/unique_lock持有mutex对象。lock_guard中的构造函数调用了.lock()，析构函数实现了.unlock()，从而使用lock_guard/unique_lock + mutex可实现异常安全的锁操作。具体代码如下：\nmutex m; void run(int a, int b, int c) { lock_guard\u0026lt;mutex\u0026gt; l(m) int d = a + b / c; } 跨线程安全的资源计数 信号量实现了这样的功能：\n 获得一个资源，资源计数器减1 释放一个资源，资源计数器加1 没有资源可以获得，线程阻塞等待  C++原生不支持信号量，可以通过lock_guard/unique_lock + mutex + int_cnt手动实现一个。具体代码如下：\nclass Semaphore { private: mutex mMutex; condition_variable mCondVar; int64_t mAvailable; public: explicit Semaphore(int64_t init) : mAvailable(init) {} void post() { { unique_lock\u0026lt;mutex\u0026gt; l(mMutex); // do computation  ++mAvailable; } mCondVar.notify_one(); } void wait() { unique_lock\u0026lt;mutex\u0026gt; l(mMutex); while (mAvailable == 0) { mCondVar.wait(l); } --mAvailable; } }; 原子操作 c++的标准库atomic可实现原子操作。 todo","title":"C++多线程同步与互斥基本原语"},{"content":"git for windows 无法显示中文，这个问题之前碰到过两次。现记录解决方案如下：\ngit config --global core.quotepath false git config --global gui.encoding utf-8\tgit config --global i18n.commit.encoding utf-8\tgit config --global i18n.logoutputencoding utf-8\texport LESSCHARSET=utf-8 参考资料\n解决 Git 在 windows 下中文乱码的问题\n","permalink":"https://hillbamboo.github.io/posts/tech/git-cannot-display-chinese/","summary":"git for windows 无法显示中文，这个问题之前碰到过两次。现记录解决方案如下：\ngit config --global core.quotepath false git config --global gui.encoding utf-8\tgit config --global i18n.commit.encoding utf-8\tgit config --global i18n.logoutputencoding utf-8\texport LESSCHARSET=utf-8 参考资料\n解决 Git 在 windows 下中文乱码的问题","title":"Git for Windows 无法显示中文"},{"content":"问题描述 动态前缀和维护问题。给定一个区间 $A[1..n]$, 对该区间进行如下两类操作\n (前缀和查询)指定$1 \\le j \\le n$, 求$A[1..j]$的前缀和 (单点修改)指定$1 \\le j \\le n$, 令A[j] += val  分析。该问题可以通过前缀数组$arr[1..n]$完成，空间复杂度是$O(n)$, 操作一的时间复杂度是$O(1)$, 操作二的时间是$O(n)$, 最坏情况是$j = n$时整个$arr[1..n]$均需要更新。树状数组能够把操作一和操作二的时间复杂度都降至$O(\\log n)$, 空间是$O(n)$.\n树状数组 树状数组是一类巧妙利用了二进制的数据结构. 在动态前缀和维护问题中，输入$1 \\le j \\le n$, 若我们能从二进制的观点来看待$j$, 则$j$至多有$\\log n$位. 举例, 易知\n$$j = 13_{10} = 1101_{2} = 8 + 4 + 1$$\n从而求数组的$A$的前13项之和可以分成三步:\n$$A[1..13] = A[1..8] + A[9..12] + A[13]$$\n注意区间$A[1..8], A[9..12], A[13]$的区间大小分别就是8, 4, 1, 这对应了13的进制分解. 我们记\n$$c[8] = A[1..8], c[12] = A[9..12], c[13] = A[13]$$\n则若我们知道了数组$c[1..n]$, 则前缀和可以在$O(\\log n)$时间内完成. 数组$c[1..n]$被称为树状数组.\n树状数组的含义 在此之前, 首先我们来明确一下$c[j]$的含义，他是指以$A[j]$结尾的往前一段区间的和, 为了方便我们称这一段区间为$c[j]$的前缀区间. $c[j]$的前缀区间有多长？如下:\n$$\\left| c[j] \\right| = j\\ \u0026amp;\\ (-j) $$\n其中符号$\u0026amp;$表示按位与. 上式的实际意义是指$j$的二进制表示中最右边的1所占的权重. 举例，如$12_{10} = 1100_{2} = 8 + 4, 4 = 12\\ \u0026amp; \\ (-12)$, 则$c[12]$的前缀区间长度是4, 同理$\\left | c[13] \\right | = 1, \\left | c[8] \\right | = 8, \\left | c[2] \\right | = 2$. 可以看出规律，凡是$j$是2的幂次形式是$c[j]$的前缀区间长度总是j, 这是因为此时j仅有一个1.\n前缀和查询 首先来考察操作一:前缀和查询操作. 给定$1 \\le j \\le n$, 怎样使用$c[1..n]$计算得到$A[1..n]$? 仍然以$j = 13$举例,\n$$ \\begin{aligned} A[1..13] \u0026amp; = A[1..8] \u0026amp; + A[9..12] \u0026amp; + A[13] \\ \u0026amp; = c[8] + \u0026amp; c[12] \u0026amp; + c[13] \\end{aligned} $$\n我们知道\n$$ \\begin{aligned} 13 \u0026amp; = 1101 + 0 = \u0026amp; 13\\ \u0026amp; = 1100 + 1 = \u0026amp; 12 + 1\\ \u0026amp; = 1000 + 101 = \u0026amp; 8 + (4 + 1) \\ \u0026amp; = 0000 + 1101 = \u0026amp; 0 + 13 \\end{aligned} $$\n从而我们可以通过反复抹除13的最右边的1来得到不同的$c[k]$, 将这些$c[k]$求和就是$A[1..j]$的值, 这样的$c[k]$总量不超过$\\log n$, 从而我们可以在$O(\\log n)$时间内完成前缀和查询. 不断抹除最右边的1可以通过j -= (j \u0026amp; -j)实现, 当然，边界条件是j \u0026gt; 0.\n前缀和查询的完整代码\n/// x = 1, 2, ..., n int sum(int x) { int ret = 0; while (x \u0026gt; 0) { ret += c[x]; x -= (x \u0026amp; -x); } return ret; } 作为特例，对于数组$A[1..n]$的单点查询可以通过 $sum(j) - sum(j - 1)$得到$A[j]$. 查询$A$的子区间和$[lo, hi]$可以通过$sum(hi) - sum(lo - 1)$实现. 时间均是 $2 \\times O(\\log n)$, 渐进阶是$O(\\log n)$\n单点修改 给定$1 \\le j \\le n$, 置 $A[j] += val$, 显然要修改$c[1..n]$中的某些值以达到动态维护区间的目的。显然$A[j]$变了, $c[j]$一定变，此外，其他所有覆盖了$A[j]$的$c[k]$均需改变，如何找到这些$c[k]$? 更直接一点，如何找了这些$k$?\n首先，显然这些$k \\ge j$. 首先来考察一个实例$j = 3 = 0011$, 容易知道$c[3]$的前缀区间长度是1, 那么只比$j = 3$大一点点的又恰能覆盖$A[3]$的$k = ?$\n我们首先取出3最右边的1，其权值恰好是$w = 1$, 我们令$4 = 3 + w = 0100$, 其值恰好是$c[4]$, 容易知道$c[4]$是第一个覆盖了$A[3]$的元素，然后下一个$k$怎么求？显然$8 = 0100 + 0100 = 4 + 4$, 我们将4的最右边的1取出，其权值$w = 4$, $c[8]$是覆盖了$c[4]$的一个元素.\n从而，我们知道k值得计算是通过j += (j \u0026amp; -j)实现的，边界是j \u0026lt;= n. 再举一个实例，修改$A[13]$，对应应修改的$c[k]$是$c[13], c[14]$. 容易知道这些$c[k]$总量同样不会超过$\\log n$个, 从而单点修改可以在$O(\\log n)$时间内完成. 单点修改完整代码如下\nvoid add(int j, int val) { while (j \u0026lt;= n) { C[j] += val; j += (j \u0026amp; -j); } } 构建树状数组 有了前两步的操作，构建一个树状数组十分直接\ninit(int* A, int n) { N = n + 1; for (int i = 0; i \u0026lt; N; ++i) c[i] = 0; for (int i = 1 /*注意*/; i \u0026lt; N; ++i) update(i, A[i - 1]); } 总结 树状数组$C[1,\\cdots,n]$是原数组$A[1,\\cdots,n]$的预处理数组，其中包含了原始数组的所有信息。其主要是二进制的思想，即\n1.sum(i). 为查询$A[1,\\cdots,i]$之和，将$i$转化为二进制数，这样在不超过$\\log i$次操作就能将前n个数之和统计出来。其具体实现只需一路沿i -= lowbit(i)计算sum +=C[i]即可,其中$i \\gt 0$. 该算法时间是$O(\\log n)$\n2.add(i,val).进行$A[i] += val$, 同样将$i$视为二进制数，这样在不超过$\\log i$次操作就能实现元素的add操作.其具体实现只需一路沿i += lowbit(i)修改C[i]+=val即可. 其中$i \\le n$. 该算法时间是$O(\\log n)$\n树状数组的初始化就是首先令$C[1..n]=0$, 然后依次调用add(i, A[i]), i =1,2,...,n.\n将下标看做二进制数，正是树状数组（Binary Indexed Tree）名字的由来，其中Binary指的是二进制而不是二叉。\n还有一个需要注意的是，树状数组中的$C[i] = Sum(A[i-lowbit(i)+1,\\cdots, i])$, 大白话就是$C[i]$是原数组$A$中以$A[i]$结尾（包含）的前$lowbit(i)$个元素之和\n树状数组的优势具有以下优势\n 实现简单 时间常数小 开了一倍空间（zkw树动态维护前缀和需要两倍空间）  ","permalink":"https://hillbamboo.github.io/posts/tech/binary-index-tree/","summary":"问题描述 动态前缀和维护问题。给定一个区间 $A[1..n]$, 对该区间进行如下两类操作\n (前缀和查询)指定$1 \\le j \\le n$, 求$A[1..j]$的前缀和 (单点修改)指定$1 \\le j \\le n$, 令A[j] += val  分析。该问题可以通过前缀数组$arr[1..n]$完成，空间复杂度是$O(n)$, 操作一的时间复杂度是$O(1)$, 操作二的时间是$O(n)$, 最坏情况是$j = n$时整个$arr[1..n]$均需要更新。树状数组能够把操作一和操作二的时间复杂度都降至$O(\\log n)$, 空间是$O(n)$.\n树状数组 树状数组是一类巧妙利用了二进制的数据结构. 在动态前缀和维护问题中，输入$1 \\le j \\le n$, 若我们能从二进制的观点来看待$j$, 则$j$至多有$\\log n$位. 举例, 易知\n$$j = 13_{10} = 1101_{2} = 8 + 4 + 1$$\n从而求数组的$A$的前13项之和可以分成三步:\n$$A[1..13] = A[1..8] + A[9..12] + A[13]$$\n注意区间$A[1..8], A[9..12], A[13]$的区间大小分别就是8, 4, 1, 这对应了13的进制分解. 我们记\n$$c[8] = A[1..8], c[12] = A[9..12], c[13] = A[13]$$\n则若我们知道了数组$c[1..n]$, 则前缀和可以在$O(\\log n)$时间内完成. 数组$c[1..n]$被称为树状数组.\n树状数组的含义 在此之前, 首先我们来明确一下$c[j]$的含义，他是指以$A[j]$结尾的往前一段区间的和, 为了方便我们称这一段区间为$c[j]$的前缀区间. $c[j]$的前缀区间有多长？如下:\n$$\\left| c[j] \\right| = j\\ \u0026amp;\\ (-j) $$\n其中符号$\u0026amp;$表示按位与. 上式的实际意义是指$j$的二进制表示中最右边的1所占的权重. 举例，如$12_{10} = 1100_{2} = 8 + 4, 4 = 12\\ \u0026amp; \\ (-12)$, 则$c[12]$的前缀区间长度是4, 同理$\\left | c[13] \\right | = 1, \\left | c[8] \\right | = 8, \\left | c[2] \\right | = 2$. 可以看出规律，凡是$j$是2的幂次形式是$c[j]$的前缀区间长度总是j, 这是因为此时j仅有一个1.\n前缀和查询 首先来考察操作一:前缀和查询操作. 给定$1 \\le j \\le n$, 怎样使用$c[1..n]$计算得到$A[1..n]$? 仍然以$j = 13$举例,","title":"树状数组: 小而美的数据结构"},{"content":"tags algos data-structure\n三行并查集 并查集是一种简洁而优雅的数据结构，能够在O(1)的时间内实现对集合的查询和合并操作。\n并查集的代码十分简洁，总共就三行\nInit(n) { for(int i = 0; i \u0026lt; n; ++i) root[i] = i;} Find(x) { return x == root[x] ? x : root[x] = find(root[x]); } Union(x, y) {root[find(x)] = find(y); } 其中root[i]表示元素i的父节点\n路径压缩 注意Find函数中使用的是递归调用, 其中将递归调用后得返回值重新赋值给root[x], 这是做法称为 路径压缩, 为了防止反复对集合进行合并后并查集退化成一条链，从而时间复杂度退化成线性时间所做的优化，注意无路径压缩的写法如下\nx == root[x] ? x : find(root[x]) 这c/c++用这种写法很OK，但是用python写，最少都要用两行\nif root[x] != x: root[x] = find(root[x]) return root[x] 用下面的这种写法是不行的:\nreturn x if root[x] == x else root[x] = find(root[x]) 此外，路径压缩自然可以改写成非递归形式，做法很简单，下文略。\n按秩归并 Union操作还可以进行按秩归并的优化. 首先介绍集合的rank的概念。 在并查集中，一个集合用一棵树表示，这棵树的深度就是该集合的rank，树越深rank越大. 容易知道rank越低find操作越高效，这也是路径压缩所追求的。按秩归并的思路是将rank低的集合并入到rank高的集合，这样可以延缓并查集变成一条链的情形，从而提高Find的效率. 若不是将小rank集合归如大rank结合，合并后的新集合的rank总会增长，最终rank=集合元素个数时，find操作是线性的。注意，为了实现按秩归并，我们仅需要多维护一个rank数组即可，足够简单。\n加上了按秩归并优化的Union函数长成下面这个样子\nvoid Union(x, y) { int xr = find(x), yr = find(y); if (rank[xr] \u0026lt;= rank[yr]) { root[xr] = yr; if (rank[xr] == rank[yr]) ++rank[yr]; } else root[yr] = xr; 按秩归并算法多了几行，为了偷懒有时随便Union也OK. 不超时就好. 讲究一点的就按秩归并吧.\n练习题  leetcode 200 leetcode 547 leetcode 684 leetcode 959 leetcode 990  后续 可持久化并查集？等我学会了再写吧~~~\n","permalink":"https://hillbamboo.github.io/posts/tech/disjoin-set/","summary":"tags algos data-structure\n三行并查集 并查集是一种简洁而优雅的数据结构，能够在O(1)的时间内实现对集合的查询和合并操作。\n并查集的代码十分简洁，总共就三行\nInit(n) { for(int i = 0; i \u0026lt; n; ++i) root[i] = i;} Find(x) { return x == root[x] ? x : root[x] = find(root[x]); } Union(x, y) {root[find(x)] = find(y); } 其中root[i]表示元素i的父节点\n路径压缩 注意Find函数中使用的是递归调用, 其中将递归调用后得返回值重新赋值给root[x], 这是做法称为 路径压缩, 为了防止反复对集合进行合并后并查集退化成一条链，从而时间复杂度退化成线性时间所做的优化，注意无路径压缩的写法如下\nx == root[x] ? x : find(root[x]) 这c/c++用这种写法很OK，但是用python写，最少都要用两行\nif root[x] != x: root[x] = find(root[x]) return root[x] 用下面的这种写法是不行的:\nreturn x if root[x] == x else root[x] = find(root[x]) 此外，路径压缩自然可以改写成非递归形式，做法很简单，下文略。\n按秩归并 Union操作还可以进行按秩归并的优化. 首先介绍集合的rank的概念。 在并查集中，一个集合用一棵树表示，这棵树的深度就是该集合的rank，树越深rank越大. 容易知道rank越低find操作越高效，这也是路径压缩所追求的。按秩归并的思路是将rank低的集合并入到rank高的集合，这样可以延缓并查集变成一条链的情形，从而提高Find的效率. 若不是将小rank集合归如大rank结合，合并后的新集合的rank总会增长，最终rank=集合元素个数时，find操作是线性的。注意，为了实现按秩归并，我们仅需要多维护一个rank数组即可，足够简单。\n加上了按秩归并优化的Union函数长成下面这个样子\nvoid Union(x, y) { int xr = find(x), yr = find(y); if (rank[xr] \u0026lt;= rank[yr]) { root[xr] = yr; if (rank[xr] == rank[yr]) ++rank[yr]; } else root[yr] = xr; 按秩归并算法多了几行，为了偷懒有时随便Union也OK. 不超时就好. 讲究一点的就按秩归并吧.\n练习题  leetcode 200 leetcode 547 leetcode 684 leetcode 959 leetcode 990  后续 可持久化并查集？等我学会了再写吧~~~","title":"三行并查集"},{"content":"什么是动态规划？ 怎样向一个四岁的小孩解释动态规划？下面是来自Quora的高票回答\nHow should I explain dynamic programming to a 4 year old?\n writes down \u0026ldquo;1+1+1+1+1+1+1+1 =\u0026rdquo; on a sheet of paper*\n\u0026ldquo;What\u0026rsquo;s that equal to?\u0026rdquo;\n(counting\u0026hellip;) \u0026ldquo;Eight!\u0026rdquo;\nwrites down another \u0026ldquo;1+\u0026rdquo; on the left*\n\u0026ldquo;What about that?\u0026rdquo;\n(quickly\u0026hellip;) \u0026ldquo;Nine!\u0026rdquo;\n\u0026ldquo;How\u0026rsquo;d you know it was nine so fast?\u0026rdquo;\n\u0026ldquo;You just added one more\u0026rdquo;\n\u0026ldquo;So you didn\u0026rsquo;t need to recount because you remembered there \u0026gt; were eight! Dynamic Programming is just a fancy way to say \u0026gt; \u0026lsquo;remembering stuff to save time later\u0026rsquo;\u0026rdquo;\n 下面的讲解是来自知乎的高票回答：\n 当你企图使用计算机解决一个问题是，其实就是在思考如何将这个问题表达成状态（用哪些变量存储哪些数据）以及如何在状态中转移（怎样根据一些变量计算出另一些变量）。所以所谓的空间复杂度就是为了支持你的计算所必需存储的状态最多有多少，所谓时间复杂度就是从初始状态到达最终状态中间需要多少步！\n每个阶段只有一个状态-\u0026gt;递推\n每个阶段的最优状态都是由上一个阶段的最优状态得到的-\u0026gt;贪心\n每个阶段的最优状态是由之前所有阶段的状态的组合得到的-\u0026gt;搜索\n每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-\u0026gt;动态规划。\n 动态规划: 形式化讲解 动态规划的三兄弟：\n 最优子结构 重叠子问题 无后效性  最优子结构是指原问题的最优解包含子问题的最优解，例如，求解斐波那契数列fib(n) = fib(n - 1) + fib(n - 2), 第n项斐波那契数必包含第n-1项和第n-2项斐波那契数。就我的经验而言，刻画最优子结构往往是最难的，我常常会因为找错了最优子结构而写错了DP转移方程。像斐波那契数，跳台阶，0-1背包等这种简单的问题，最优子结构很容易刻画，因为当前状态(i,j) 仅依赖于很少的的几个先前的状态，从而状态转移方程是很容易写出来的。然而，常常问题一复杂，其中牵涉的状态较多时，状态转移会变得很复杂，很容易把子问题想错，或者想漏了。在刻画最优子结构时，必须考察完全其最优解需要的所有子问题，做到不重不漏。\n还有一点，考虑当前状态(i, j)是从先前的哪些状态转移过来时，是一个决策的过程，所有容许的可能决策构成一个允许决策集，这个集合是由原问题给出的，也是由怎样去设计状态所决定的，并不是自己空想的、臆造的。\n重叠子问题是指将原问题分解成许多的子问题后，这些子问题都是相互关联的，有所重叠的，这样使用DP才会加速计算。如果发现问题存在大量的重叠子问题，该问题就很有可能能用DP来解。这点也是DP和分治的显著区别，如果子问题是独立的，直接用分支就能解，也就无所谓DP不DP。例如对于排序问题，将其分解为左右两个子段的排序问题，求解这两个子问题是相互独立的，从而这里并不存在重叠子问题。\n四步走\n 划分阶段 确定状态 寻找最优子结构  (从特例出发考虑最优子结构) 考虑最优子结构的一般情况，注意考虑周全   写出状态转移方程和边界情况(平凡/退化情况), 注意边界不要写漏  三步走\n 划分阶段 考虑平凡情况，如当数组长度为0时 考虑一般情况， 如规模为i的问题已解决，如何基于此求解规模为i+1的问题  1-\u0026gt;2-\u0026gt;3-\u0026gt;4, 1-\u0026gt;4-\u0026gt;2-\u0026gt;3\n例题讲解 三大算法思路: 搜索，贪心，dp，分治\nfib数列 青蛙跳 变态青蛙跳 挖金矿 花瓶美学 数字三角形 背包九问 最长公共子序列 单源最短路径问题\n参考资源 How should I explain dynamic programming to a 4-year-old?\n知乎\n知乎\n知乎\n","permalink":"https://hillbamboo.github.io/posts/tech/dp-basic/","summary":"什么是动态规划？ 怎样向一个四岁的小孩解释动态规划？下面是来自Quora的高票回答\nHow should I explain dynamic programming to a 4 year old?\n writes down \u0026ldquo;1+1+1+1+1+1+1+1 =\u0026rdquo; on a sheet of paper*\n\u0026ldquo;What\u0026rsquo;s that equal to?\u0026rdquo;\n(counting\u0026hellip;) \u0026ldquo;Eight!\u0026rdquo;\nwrites down another \u0026ldquo;1+\u0026rdquo; on the left*\n\u0026ldquo;What about that?\u0026rdquo;\n(quickly\u0026hellip;) \u0026ldquo;Nine!\u0026rdquo;\n\u0026ldquo;How\u0026rsquo;d you know it was nine so fast?\u0026rdquo;\n\u0026ldquo;You just added one more\u0026rdquo;\n\u0026ldquo;So you didn\u0026rsquo;t need to recount because you remembered there \u0026gt; were eight! Dynamic Programming is just a fancy way to say \u0026gt; \u0026lsquo;remembering stuff to save time later\u0026rsquo;\u0026rdquo;\n 下面的讲解是来自知乎的高票回答：\n 当你企图使用计算机解决一个问题是，其实就是在思考如何将这个问题表达成状态（用哪些变量存储哪些数据）以及如何在状态中转移（怎样根据一些变量计算出另一些变量）。所以所谓的空间复杂度就是为了支持你的计算所必需存储的状态最多有多少，所谓时间复杂度就是从初始状态到达最终状态中间需要多少步！\n每个阶段只有一个状态-\u0026gt;递推\n每个阶段的最优状态都是由上一个阶段的最优状态得到的-\u0026gt;贪心\n每个阶段的最优状态是由之前所有阶段的状态的组合得到的-\u0026gt;搜索\n每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-\u0026gt;动态规划。\n 动态规划: 形式化讲解 动态规划的三兄弟：\n 最优子结构 重叠子问题 无后效性  最优子结构是指原问题的最优解包含子问题的最优解，例如，求解斐波那契数列fib(n) = fib(n - 1) + fib(n - 2), 第n项斐波那契数必包含第n-1项和第n-2项斐波那契数。就我的经验而言，刻画最优子结构往往是最难的，我常常会因为找错了最优子结构而写错了DP转移方程。像斐波那契数，跳台阶，0-1背包等这种简单的问题，最优子结构很容易刻画，因为当前状态(i,j) 仅依赖于很少的的几个先前的状态，从而状态转移方程是很容易写出来的。然而，常常问题一复杂，其中牵涉的状态较多时，状态转移会变得很复杂，很容易把子问题想错，或者想漏了。在刻画最优子结构时，必须考察完全其最优解需要的所有子问题，做到不重不漏。\n还有一点，考虑当前状态(i, j)是从先前的哪些状态转移过来时，是一个决策的过程，所有容许的可能决策构成一个允许决策集，这个集合是由原问题给出的，也是由怎样去设计状态所决定的，并不是自己空想的、臆造的。\n重叠子问题是指将原问题分解成许多的子问题后，这些子问题都是相互关联的，有所重叠的，这样使用DP才会加速计算。如果发现问题存在大量的重叠子问题，该问题就很有可能能用DP来解。这点也是DP和分治的显著区别，如果子问题是独立的，直接用分支就能解，也就无所谓DP不DP。例如对于排序问题，将其分解为左右两个子段的排序问题，求解这两个子问题是相互独立的，从而这里并不存在重叠子问题。\n四步走\n 划分阶段 确定状态 寻找最优子结构  (从特例出发考虑最优子结构) 考虑最优子结构的一般情况，注意考虑周全   写出状态转移方程和边界情况(平凡/退化情况), 注意边界不要写漏  三步走\n 划分阶段 考虑平凡情况，如当数组长度为0时 考虑一般情况， 如规模为i的问题已解决，如何基于此求解规模为i+1的问题  1-\u0026gt;2-\u0026gt;3-\u0026gt;4, 1-\u0026gt;4-\u0026gt;2-\u0026gt;3\n例题讲解 三大算法思路: 搜索，贪心，dp，分治\nfib数列 青蛙跳 变态青蛙跳 挖金矿 花瓶美学 数字三角形 背包九问 最长公共子序列 单源最短路径问题","title":"动态规划初步"},{"content":"朴素贝叶斯是一类很简单的分类算法, 应用场景较多, 如垃圾邮件分类, 输入法中的拼写检查, 文本情感分类等等. 初学朴素贝叶斯时被\u0026quot;朴素\u0026quot;二字迷惑, 认为之所以称之为 \u0026ldquo;朴素\u0026rdquo; 时因为算法很 \u0026ldquo;简单\u0026rdquo;, 很naive. 实际上, \u0026ldquo;朴素\u0026rdquo; 更准确的含义是（特征间的）条件独立性假设, 由于这一假设使得这个算法很 \u0026ldquo;naive\u0026rdquo;, 他的引入是为了简化后验概率的计算. 学习算法不能走马观花, 浅尝辄止, 还是得花时间好好琢磨.\n贝叶斯公式 先补充贝叶斯公式作为预备知识. 贝叶斯公式形如下式： 其中$\\mathbb{x}$表示样本, $c$表示类别, 贝叶斯公式给出了样本与类别之间的生成关系. 更通俗地讲, 假设给定未知样本$\\mathbb{x}$, $c$的可能取值是 ${0, 1, 2, \\cdots, k}$, 则概率\n$$Pr(c=j|\\mathbb{x}) = \\frac{Pr(\\mathbb{x}|c=j) \\times Pr(c = j)}{Pr(\\mathbb{x})}, \\ j=0, 1, \\cdots, k$$\n朴素贝叶斯算法 朴素贝叶斯模型是一类生成模型, 它的生成关系有贝叶斯公式给出, 模型的训练是通过最大化后验概率实现的.\n模型假设 朴素贝叶斯算法的前提假设是特征之间的条件独立性, 即： 给定样本$\\mathbb{x}=(x_1, x_2, \\cdots, x_n)$, 其中$x_i$为第$i$个特征, 则\n$$Pr(\\mathbb{x}|c=j) = Pr(c=j) \\times \\prod\\limits_{i}Pr(x_i|c=j)$$\n算法推导 由贝叶斯公式可知\n$$Pr(c=j|\\mathbb{x}) = \\frac{Pr(\\mathbb{x}|c=j) \\times Pr(c = j)}{Pr(\\mathbb{x})}, \\ j=0, 1, \\cdots, k$$\n由于对于同一个样本, $Pr(\\mathbb{x})$取值总是相同的, 从而\n$$ \\begin{aligned} j^{*} \u0026amp;= \\mathop{\\arg\\max}\\limits_{j} \\frac{Pr(c = j) \\times \\prod\\limits_{i}Pr(x_i|c = j)}{Pr(\\mathbb{x})} \\ \u0026amp; = \\mathop{\\arg\\max}\\limits_{j} Pr(c = j) \\times \\prod\\limits_{i}Pr(x_i|c = j) \\end{aligned} $$\n其中, $j^{*}$即为样本$\\mathbb{x}$的预测类别\n算法流程 朴素贝叶斯算法的训练过程就是一个\u0026quot;计数\u0026quot;过程. 具体来说, 它对训练集统计下列两类概率\n 先验概率（类概率） $$Pr(c = j) = \\frac{\\left| D_{c=j}\\right|}{\\left| D\\right|}$$, 其中 $\\left| D_{c=j}\\right|$ 为数据集中的类别 $j$所占的数目, $\\left| D\\right|$为数据集的大小 条件概率（似然） $$ Pr(x_i|c = j) = \\begin{cases} \\frac{\\left| D_{x_i, c=j} \\right| }{\\left| D_{c} \\right| }, \u0026amp; 若\\ x\\ 离散, \\ \\frac{1}{\\sigma \\sqrt{2\\pi}}\\cdot \\exp\\left( -\\frac{\\left( x_i - \\mu\\right)^2}{2\\sigma^2}\\right), \u0026amp; 若\\ x\\ 连续, \\end{cases} $$ 其中$\\left| D_{x_i, c=j} \\right|$为类别是$j$且取值为$x_i$的样本数量. $\\mu, \\sigma$分别是特征$x_i$的均值与方差  朴素贝叶斯算法的整体流程如下图所示:\n注意项   条件概率连乘积下溢. 若特征数量很多, 则 $$\\prod\\limits_{i}Pr(x_i|c=j)$$ 越接近0. 这种现象称为乘法下溢. 为改进之, 可使用对数似然, 即计算 $$LL\\left( \\mathbb{x}|c= j\\right) = \\log(Pr(c=j)) + \\sum\\limits_{i}\\log(Pr(x_i|c=j))$$\n  未登录词. 若带预测样本中出现了训练集中从未出现过的特征取值, 则后验概率总为0, 为了克服这一点, 可以引入拉普拉斯平滑, 即计算 $$ \\hat {Pr}(c = j) = \\frac{\\left| D_{c=j}\\right| + \\lambda}{\\left| D\\right| + N_j \\cdot \\lambda} \\\n\\hat {Pr}(\\mathbb{x}) = \\frac{\\left| D_{x_i, c=j} \\right| + \\lambda}{\\left| D_{c} \\right| + N_{i} \\cdot \\lambda} $$ 其中, $N_j$为类别$j$的数量, $N_{i}$为特征$x_i$的可能取值数目, $\\lambda$为大于0的常数, 常取值为1\n  总结   朴素贝叶斯算法的主要优点：\n 对小规模的数据表现很好, 能个处理多分类任务, 适合增量式训练, 尤其是数据量超出内存时, 我们可以一批批的去增量训练. 对缺失数据不太敏感, 常用于文本分类 不受特征尺度的影响, 由于训练过程就是计数的过程, 从而无需归一化等操作    朴素贝叶斯的主要缺点：\n 需要知道先验概率, 且先验概率很多时候取决于假设, 假设的模型可以有很多种, 因此在某些时候会由于假设的先验模型的原因导致预测效果不佳 由于我们是通过先验和数据来决定后验的概率从而决定分类, 所以分类决策存在一定的错误率    使用朴素贝叶斯算法时的注意点：\n 贝叶斯分类器与一般意义上的\u0026quot;贝叶斯学习\u0026quot;不同, 前者是通过最大后验概率进行单点估计, 后者是进行分布估计 没有平滑之前的朴素贝叶斯算法使用的是极大似然估计, 属于频率派, 平滑之后的进行的是贝叶斯估计, 属于贝叶斯学派 使用对数似然和拉普拉斯平滑是两种不错的改进方式    参考资源  周志华, 机器学习 朴素贝叶斯算法原理小结 算法杂货铺——分类算法之朴素贝叶斯分类(Naive Bayesian classification)  ","permalink":"https://hillbamboo.github.io/posts/tech/naive-bayes/","summary":"朴素贝叶斯是一类很简单的分类算法, 应用场景较多, 如垃圾邮件分类, 输入法中的拼写检查, 文本情感分类等等. 初学朴素贝叶斯时被\u0026quot;朴素\u0026quot;二字迷惑, 认为之所以称之为 \u0026ldquo;朴素\u0026rdquo; 时因为算法很 \u0026ldquo;简单\u0026rdquo;, 很naive. 实际上, \u0026ldquo;朴素\u0026rdquo; 更准确的含义是（特征间的）条件独立性假设, 由于这一假设使得这个算法很 \u0026ldquo;naive\u0026rdquo;, 他的引入是为了简化后验概率的计算. 学习算法不能走马观花, 浅尝辄止, 还是得花时间好好琢磨.\n贝叶斯公式 先补充贝叶斯公式作为预备知识. 贝叶斯公式形如下式： 其中$\\mathbb{x}$表示样本, $c$表示类别, 贝叶斯公式给出了样本与类别之间的生成关系. 更通俗地讲, 假设给定未知样本$\\mathbb{x}$, $c$的可能取值是 ${0, 1, 2, \\cdots, k}$, 则概率\n$$Pr(c=j|\\mathbb{x}) = \\frac{Pr(\\mathbb{x}|c=j) \\times Pr(c = j)}{Pr(\\mathbb{x})}, \\ j=0, 1, \\cdots, k$$\n朴素贝叶斯算法 朴素贝叶斯模型是一类生成模型, 它的生成关系有贝叶斯公式给出, 模型的训练是通过最大化后验概率实现的.\n模型假设 朴素贝叶斯算法的前提假设是特征之间的条件独立性, 即： 给定样本$\\mathbb{x}=(x_1, x_2, \\cdots, x_n)$, 其中$x_i$为第$i$个特征, 则\n$$Pr(\\mathbb{x}|c=j) = Pr(c=j) \\times \\prod\\limits_{i}Pr(x_i|c=j)$$\n算法推导 由贝叶斯公式可知\n$$Pr(c=j|\\mathbb{x}) = \\frac{Pr(\\mathbb{x}|c=j) \\times Pr(c = j)}{Pr(\\mathbb{x})}, \\ j=0, 1, \\cdots, k$$\n由于对于同一个样本, $Pr(\\mathbb{x})$取值总是相同的, 从而\n$$ \\begin{aligned} j^{*} \u0026amp;= \\mathop{\\arg\\max}\\limits_{j} \\frac{Pr(c = j) \\times \\prod\\limits_{i}Pr(x_i|c = j)}{Pr(\\mathbb{x})} \\ \u0026amp; = \\mathop{\\arg\\max}\\limits_{j} Pr(c = j) \\times \\prod\\limits_{i}Pr(x_i|c = j) \\end{aligned} $$\n其中, $j^{*}$即为样本$\\mathbb{x}$的预测类别\n算法流程 朴素贝叶斯算法的训练过程就是一个\u0026quot;计数\u0026quot;过程. 具体来说, 它对训练集统计下列两类概率\n 先验概率（类概率） $$Pr(c = j) = \\frac{\\left| D_{c=j}\\right|}{\\left| D\\right|}$$, 其中 $\\left| D_{c=j}\\right|$ 为数据集中的类别 $j$所占的数目, $\\left| D\\right|$为数据集的大小 条件概率（似然） $$ Pr(x_i|c = j) = \\begin{cases} \\frac{\\left| D_{x_i, c=j} \\right| }{\\left| D_{c} \\right| }, \u0026amp; 若\\ x\\ 离散, \\ \\frac{1}{\\sigma \\sqrt{2\\pi}}\\cdot \\exp\\left( -\\frac{\\left( x_i - \\mu\\right)^2}{2\\sigma^2}\\right), \u0026amp; 若\\ x\\ 连续, \\end{cases} $$ 其中$\\left| D_{x_i, c=j} \\right|$为类别是$j$且取值为$x_i$的样本数量.","title":"机器学习算法: 朴素贝叶斯篇"},{"content":"GBDT是一个加法模型，其基模型是决策树，所以名字中带着DT，使用的优化方式是梯度提升，所以名字中带有GB. GDBT类模型如xgb, lgb, catboost, thunderboost都是GBDT的改进版本\n基本推导 GBDT的基本形式：\nXGB $$ J^{(t-1)} = \\sum_{j \\in T}\\left[\\left( \\sum_{i \\in I_j} g_i\\right)w_j + \\frac{1}{2}\\left(\\sum_{i \\in I_j}h_i + \\lambda \\right)w_j^2 \\right] + \\gamma T \\ = \\sum_{j \\in T}\\left[G_jw_j + \\frac{1}{2}\\left(H_j + \\lambda \\right)w_j^2 \\right] + \\gamma T $$\n其中 G_j 是落入第\\(j\\)个叶节点的样本一阶梯度之和， H_j 是落入第\\(j\\)个叶节点的样本的二阶梯度之和， 对于式\n$$ G_jw_j + \\frac{1}{2}\\left(H_j + \\lambda \\right)w_j^2 $$ $w_j$相当于自变量$x$，从而 $$ w_j = -\\frac{G_i}{H_j + \\lambda} $$ 时该式取得最小值，将其带入目标函数中，得到\n$$J^{(t)} = -\\frac{1}{2}\\sum_{j=1, \\cdots , T}\\frac{G_j^2}{H_j + \\lambda} + \\gamma T$$\n参考资料  GBDT的原理和应用  ","permalink":"https://hillbamboo.github.io/posts/tech/learn-xgb/","summary":"GBDT是一个加法模型，其基模型是决策树，所以名字中带着DT，使用的优化方式是梯度提升，所以名字中带有GB. GDBT类模型如xgb, lgb, catboost, thunderboost都是GBDT的改进版本\n基本推导 GBDT的基本形式：\nXGB $$ J^{(t-1)} = \\sum_{j \\in T}\\left[\\left( \\sum_{i \\in I_j} g_i\\right)w_j + \\frac{1}{2}\\left(\\sum_{i \\in I_j}h_i + \\lambda \\right)w_j^2 \\right] + \\gamma T \\ = \\sum_{j \\in T}\\left[G_jw_j + \\frac{1}{2}\\left(H_j + \\lambda \\right)w_j^2 \\right] + \\gamma T $$\n其中 G_j 是落入第\\(j\\)个叶节点的样本一阶梯度之和， H_j 是落入第\\(j\\)个叶节点的样本的二阶梯度之和， 对于式\n$$ G_jw_j + \\frac{1}{2}\\left(H_j + \\lambda \\right)w_j^2 $$ $w_j$相当于自变量$x$，从而 $$ w_j = -\\frac{G_i}{H_j + \\lambda} $$ 时该式取得最小值，将其带入目标函数中，得到\n$$J^{(t)} = -\\frac{1}{2}\\sum_{j=1, \\cdots , T}\\frac{G_j^2}{H_j + \\lambda} + \\gamma T$$\n参考资料  GBDT的原理和应用  ","title":"XGB"},{"content":"安装jupyter notebook  插件 table of content 用于为长文本生成目录 一些color scheme, background image 之类  安装jupyter lab  为jupyter lab 安装插件  pixiedust: IBM的notebook debugger 安装 jupyterlab-variableInspector 用于更快捷地观察变量, 妈妈再也不用担心我整天print变量了    ","permalink":"https://hillbamboo.github.io/posts/tech/setup-jupyterlab-interactive-computational-envs/","summary":"安装jupyter notebook  插件 table of content 用于为长文本生成目录 一些color scheme, background image 之类  安装jupyter lab  为jupyter lab 安装插件  pixiedust: IBM的notebook debugger 安装 jupyterlab-variableInspector 用于更快捷地观察变量, 妈妈再也不用担心我整天print变量了    ","title":"Jupyterlab交互式环境配置"},{"content":"面试流程  电话面试 远程面试 现场面试  在电话面试中，要用尽可能简洁和形象化的语言讲述问题；\n在远程面试中，重点考察的是编码的能力，要注意以下三点：\n 想清楚再写 使用单元测试 注意代码风格 在编码之前，应该先写写单元测试（或构造一些边界情况）  现场面应该注意：\n 提前规划好路线及估算好时间，预留30min作缓冲 提前追备好几个问题问面试官  一场面试中的环节  自我介绍 (30s - 1min) 项目经历 (5min - 10min) 技术考察 (40min - 50min) 应聘者提问 (~5min)  自我介绍 暖场用\n项目经历 建议使用以下的框架讲述自己的项目经历\n Situation (简述项目的背景，如规模，功能，目标群体等等) Task (已完成的任务，注意用词：参与 vs 负责) Action (做了什么工作，怎么做的) Result (自己的贡献，完成了多少的功能，做了多少的优化，提升了多少的功能)  常见套路：\n 项目中遇到的最大的问题是什么？如何克服的？ 从这个项目中学到了什么？ 团队协作中遇到过什么问题？如何解决的？ 为什么跳槽/为什么选择与本专业不同的职业？  回答为什么跳槽这类的问题，模板：在原来的工作岗位上没有了激情，寻求新环境改变、提升自己. 比如说自己在原工作上做了好多年，技能上没有了上升的空间，寻找 一家新的公司获得提升.\n技术考察 通常是题目的考察。一定要注意，在写代码之前先和面试官沟通好，明确题意是什么，再讲述自己的解题思路，还要说说自己构造的测试用例，体现自己思考问题的严谨性与全面性。\n应聘者提问 不要问什么公司未来的发展战略的问题，作为一线的开发者，问问关于自身岗位的问题，也不要去谈薪资，谈你是否会给我offer之类的问题.\n面试能力的考察  沟通能力 学习能力  在沟通能力中，常见的套路是面试官提出一个描述并不清楚的问题，试图让面试者通过反复的沟通理解题意。从而，面试者要有主动沟通的意识 在考察学习能力方面，常见的两个套路：1. 最近在看什么书或项目？2. 试图让面试者解决他所不熟悉的领域问题，或者一个新概念，让面试者试图解决问题。 沟通能力和学习能力的考察常常交织在一起，要注意灵活应对。\n总结  主动沟通意识 想清楚再写 先和面试官讲清楚解题的思路 进行单元测试  参考资料  何海涛. 剑指offer第二版  ","permalink":"https://hillbamboo.github.io/posts/tech/sword-to-offer/","summary":"面试流程  电话面试 远程面试 现场面试  在电话面试中，要用尽可能简洁和形象化的语言讲述问题；\n在远程面试中，重点考察的是编码的能力，要注意以下三点：\n 想清楚再写 使用单元测试 注意代码风格 在编码之前，应该先写写单元测试（或构造一些边界情况）  现场面应该注意：\n 提前规划好路线及估算好时间，预留30min作缓冲 提前追备好几个问题问面试官  一场面试中的环节  自我介绍 (30s - 1min) 项目经历 (5min - 10min) 技术考察 (40min - 50min) 应聘者提问 (~5min)  自我介绍 暖场用\n项目经历 建议使用以下的框架讲述自己的项目经历\n Situation (简述项目的背景，如规模，功能，目标群体等等) Task (已完成的任务，注意用词：参与 vs 负责) Action (做了什么工作，怎么做的) Result (自己的贡献，完成了多少的功能，做了多少的优化，提升了多少的功能)  常见套路：\n 项目中遇到的最大的问题是什么？如何克服的？ 从这个项目中学到了什么？ 团队协作中遇到过什么问题？如何解决的？ 为什么跳槽/为什么选择与本专业不同的职业？  回答为什么跳槽这类的问题，模板：在原来的工作岗位上没有了激情，寻求新环境改变、提升自己. 比如说自己在原工作上做了好多年，技能上没有了上升的空间，寻找 一家新的公司获得提升.\n技术考察 通常是题目的考察。一定要注意，在写代码之前先和面试官沟通好，明确题意是什么，再讲述自己的解题思路，还要说说自己构造的测试用例，体现自己思考问题的严谨性与全面性。\n应聘者提问 不要问什么公司未来的发展战略的问题，作为一线的开发者，问问关于自身岗位的问题，也不要去谈薪资，谈你是否会给我offer之类的问题.\n面试能力的考察  沟通能力 学习能力  在沟通能力中，常见的套路是面试官提出一个描述并不清楚的问题，试图让面试者通过反复的沟通理解题意。从而，面试者要有主动沟通的意识 在考察学习能力方面，常见的两个套路：1. 最近在看什么书或项目？2. 试图让面试者解决他所不熟悉的领域问题，或者一个新概念，让面试者试图解决问题。 沟通能力和学习能力的考察常常交织在一起，要注意灵活应对。\n总结  主动沟通意识 想清楚再写 先和面试官讲清楚解题的思路 进行单元测试  参考资料  何海涛. 剑指offer第二版  ","title":"剑指offter读书笔记"},{"content":"作为三大经典排序算法的堆排序，借助了堆这种精巧的数据结构，实现了排序. 理解了堆结构，再理解堆排序就不难了.\n堆排序中三点要重点掌握：\n 怎样通过下标找到节点的父节点及子节点 建堆算法 堆调整算法  什么是堆 堆是一种数据结构，能够支持高效的操作.堆得一种经典实现是使用完全二叉树，这种实现也被称为完全二叉堆.事实上，堆的树结构只是它的一种逻辑结构，也就是画在纸的，在我们脑海中想象出来的，实际内存中的物理结构，常常是使用数组. 有时候堆也被称为优先级队列，这是它的逻辑上的名字，别人用起来就好像是这种结构具有某种优先级.一般来说，堆分两种: 大根堆和小根堆.作为一种数据结构，考察堆的增删改查操作.修改在堆中并不常见，忽略. 查找操作也只限定在查找最大值/最小值上. 增加操作通常加在堆的最后，删除操作通常删除根节点.\n堆与数组的转化 堆结构和数组具有很好的对应，即给定一个规模为n的二叉堆，给堆得层序遍历序列对应的就是一个数组，大小同样为n. 从而，有了一个数组，就能把这个数组当成堆来用.使用三个公式即可找到任意节点i的父节点，左节点和右节点（如果有的话）. 假设大小为n的数组arr，下标记为$i = 0, 1, \\cdots, n - 1$, 则其左节点的下标为 $2 \\cdot i + 1$, 其右节点（如果有）的下标为 $2 \\cdot i + 2$, 对于下标为j的节点，其父节点的下标为 $(j - 1) / 2$, 注意当$j = 0$ 时 其父节点时自身，$(0 - 1) / 2 = 0$ 不会越界.\n建堆与维护堆 堆中，最重要的两种操作是：建堆和维护堆.建堆是指给定一组数据，比如就是一个数组，通过某种算法将其调整为一个堆（调整操作也就是调整数组中元素的位置）；维护堆是指当增删后的堆不再是一个堆时，用某种算法将其再次调整为一个合法的堆.一个合法的堆是指该堆满足堆序性，对于大根堆，堆序性是指根节点是堆中最大值，对于小根堆，定义类似.\n已知对于一棵高度为h的满二叉树，其规模$n = 2^{(h + 1)}- 1$, 即 $h = O(\\log n)$，\n下面讨论建堆算法和堆调整算法.\n建堆 最开始的思路 任意给定一个大小为n的数组，从零位置的元素出发，即从空堆出发，不断将新元素加入堆中，堆的增加操作复杂度为O(logn), 从而要建立一个大小为n的堆，复杂度为：\n$$\\log 1 + \\log 2 + \u0026hellip; + \\log n = O(n\\log n)$$\n更细致的复杂度分析，假定一个规模为n的堆高度是h, 则该堆中第i层的节点个数是2^i, 其中 0 \u0026lt;= i \u0026lt; h, 建堆需要每一个元素i都上溯，则复杂度：\n$$1 \\cdot 2^1 + 2 \\cdot 2^2 + \u0026hellip; + h \\cdot 2^h = O(n \\log n)$$\nFloyd算法 算法一过于复杂，建堆就需要O(nlogn)，还不如使用快排或归排.我们需要一个更高效的算法. 从相反的思路考虑，假设堆已经建好了，我们需要做的是调整堆，即下沉操作.时间复杂度：\n$$(h - 1) \\cdot 2^1 + (h - 2) \\cdot 2^2 + \u0026hellip; + (h - h) \\cdot 2^h = O(n)$$\nDone!\n维护堆 堆的维护发生在增加或删除操作之后.\n对于增加操作，新元素被添加至树的最后一层，最坏情况下该元素需要O(logn)次操作上溯至根节点的位置，才能保证对的合法性；对于删除操作，根节点被删除，堆的最后一个节点被移至根节点的位置，最多需要O(logn)次操作下沉至最后一层，才能保证新堆的合法性.\n综上，堆的调整算法复杂度是O(logn).\n堆排序 有了堆结构，排序就变得很简单了.只需O(1)的辅助空间，O(nlogn)的时间就能实排序.给定一个无序数组，该数组被看作是 [堆(无序区) | 有序区]， 堆排序的过程就是不断交换无序区中的首尾元素（等效于弹出最大值，然后用末元素顶替根元素）， 由此堆不再合法，调用调整算法使其重新称为一个合法堆， 此番操作后有序区扩大，无序区收缩，反复这个过程，遇到空堆时算法终止·\n复杂度分析: 堆中n个元素都历经交换和堆调整算法，耗时O(logn)，从而最终复杂度为 O(nlogn).\n","permalink":"https://hillbamboo.github.io/posts/tech/heap-heapsort/","summary":"作为三大经典排序算法的堆排序，借助了堆这种精巧的数据结构，实现了排序. 理解了堆结构，再理解堆排序就不难了.\n堆排序中三点要重点掌握：\n 怎样通过下标找到节点的父节点及子节点 建堆算法 堆调整算法  什么是堆 堆是一种数据结构，能够支持高效的操作.堆得一种经典实现是使用完全二叉树，这种实现也被称为完全二叉堆.事实上，堆的树结构只是它的一种逻辑结构，也就是画在纸的，在我们脑海中想象出来的，实际内存中的物理结构，常常是使用数组. 有时候堆也被称为优先级队列，这是它的逻辑上的名字，别人用起来就好像是这种结构具有某种优先级.一般来说，堆分两种: 大根堆和小根堆.作为一种数据结构，考察堆的增删改查操作.修改在堆中并不常见，忽略. 查找操作也只限定在查找最大值/最小值上. 增加操作通常加在堆的最后，删除操作通常删除根节点.\n堆与数组的转化 堆结构和数组具有很好的对应，即给定一个规模为n的二叉堆，给堆得层序遍历序列对应的就是一个数组，大小同样为n. 从而，有了一个数组，就能把这个数组当成堆来用.使用三个公式即可找到任意节点i的父节点，左节点和右节点（如果有的话）. 假设大小为n的数组arr，下标记为$i = 0, 1, \\cdots, n - 1$, 则其左节点的下标为 $2 \\cdot i + 1$, 其右节点（如果有）的下标为 $2 \\cdot i + 2$, 对于下标为j的节点，其父节点的下标为 $(j - 1) / 2$, 注意当$j = 0$ 时 其父节点时自身，$(0 - 1) / 2 = 0$ 不会越界.\n建堆与维护堆 堆中，最重要的两种操作是：建堆和维护堆.建堆是指给定一组数据，比如就是一个数组，通过某种算法将其调整为一个堆（调整操作也就是调整数组中元素的位置）；维护堆是指当增删后的堆不再是一个堆时，用某种算法将其再次调整为一个合法的堆.一个合法的堆是指该堆满足堆序性，对于大根堆，堆序性是指根节点是堆中最大值，对于小根堆，定义类似.\n已知对于一棵高度为h的满二叉树，其规模$n = 2^{(h + 1)}- 1$, 即 $h = O(\\log n)$，\n下面讨论建堆算法和堆调整算法.\n建堆 最开始的思路 任意给定一个大小为n的数组，从零位置的元素出发，即从空堆出发，不断将新元素加入堆中，堆的增加操作复杂度为O(logn), 从而要建立一个大小为n的堆，复杂度为：\n$$\\log 1 + \\log 2 + \u0026hellip; + \\log n = O(n\\log n)$$\n更细致的复杂度分析，假定一个规模为n的堆高度是h, 则该堆中第i层的节点个数是2^i, 其中 0 \u0026lt;= i \u0026lt; h, 建堆需要每一个元素i都上溯，则复杂度：\n$$1 \\cdot 2^1 + 2 \\cdot 2^2 + \u0026hellip; + h \\cdot 2^h = O(n \\log n)$$\nFloyd算法 算法一过于复杂，建堆就需要O(nlogn)，还不如使用快排或归排.我们需要一个更高效的算法. 从相反的思路考虑，假设堆已经建好了，我们需要做的是调整堆，即下沉操作.时间复杂度：\n$$(h - 1) \\cdot 2^1 + (h - 2) \\cdot 2^2 + \u0026hellip; + (h - h) \\cdot 2^h = O(n)$$\nDone!\n维护堆 堆的维护发生在增加或删除操作之后.\n对于增加操作，新元素被添加至树的最后一层，最坏情况下该元素需要O(logn)次操作上溯至根节点的位置，才能保证对的合法性；对于删除操作，根节点被删除，堆的最后一个节点被移至根节点的位置，最多需要O(logn)次操作下沉至最后一层，才能保证新堆的合法性.","title":"堆与堆排序"},{"content":"chapter 2. 模型选择和评估 Q1：什么模型才是好的模型？ A1：泛化能力强的（即泛化误差小的）模型是更好的模型 Q2：怎样知道模型的泛化能力？ A2：思路：将数据集分为训练/验证集，在训练集上训练模型，在验证集上跑模型得到的预测误差近似认为是泛化误差 Q3：具体来说，应该怎样对数据集进行划分？ A3：常用三种划分方法：\n hand-out: 直接按比例划分 k-fold：k折交叉验证，特殊形式：留一法 boostrap sampling: 放回抽样  Q4：如何度量模型的预测误差？（怎样才能判断一个模型表现得更好？） A4：有很多的量化指标可以用来度量模型的误差，常用的有：错误率、正确率、查全率、查准率、F-1、 ROC、AUC、confusion matrix、cost matrix、F-beta、cost-sensitive curve、P-R图、BEP、cost curve等等\n[Notes]\n 过拟合无法避免，我们只能缓解或是降低其发生的风险 训练/验证集要能够充分反映数据的原始规律 在不少的应用任务中，参数调得好不好往往对最终模型性能有着关键性影响 同一算法，不同参数，会产生不同的模型；不同算法，不同参数，会产生更多不同的模型  [Tips]\n 在验证集上进行完了模型选择和调参后，记得要在全体数据集（训练+验证集）上在跑一遍模型 直观理解查全率、查准率、F-1（P30） 记住 bias-varance 平衡的那张图  chapter 3. 线性模型 Q1：什么是线性模型？什么是广义线性模型？ A1：线性模型：形如 y_hat = W_TX+b 广义线性模型：形如 y_hat = g(W_TX+b)\nQ2：怎样从二分类问题推广到多分类问题？ A2：思路：通过组合多个二分类器，得到一个多分类器 具体：\n OVO：对于N个类别，训练 N(N-1)/2 个分类器 OVR：对于N个类别，训练 N 个分类器 MvM: 常用 ECOC技术  Q3：怎样处理类别不平衡问题？ A3：\n 欠抽样（undersampling）: 丢弃样本（但是不能随便丢弃，否则会丢失重要信息） 过抽样（oversampling）: 增加样本（但是不能简单重复，否则会造成过拟合） 阈值移动（threshold-moving）: 再缩放/再平衡  chapter 4. 决策树 Q1：什么是决策树？ A1：形如 【此处应该有图】\nQ2：怎样生成一棵决策树？ A2：不同的算法基于不同的原则，如ID3基于信息增益原则，C4.5基于增益率原则，CART基于基尼指数\nQ3：怎样对决策树进行剪枝？ A3：常用两种剪枝策略： 1、预剪枝：训练时间短，但易于欠拟合 2、后剪枝：训练时间长，但不易欠拟合\nQ4：怎样处理缺失值和连续值？ A4：缺失值：C4.5 连续值：连续变量离散化，常用二分法\nNotes  为了生成一棵决策树，就要合理的选择特征作为一系列的决策变量，为了怎样合理的选择特征这一问题，诞生了一系列的决策树算法 信息增益原则对可取值数目较多的特征有偏好；增益率原则对于可取值数目较少的特征有偏好 决策树决定的决策边界有一个明显的特征：轴平行 单决策树：【此处应该有图】；多变量决策树：【此处应该有图】  chapter 8. 集成学习 Q1：什么是模型融合？ A1： 通过某种方式训练和组合多个模型，最终得到一个总的模型\nQ2：为什么模型融合是可行的？ A2： “好而不同”的单个模型，通过某种有效的方式组合在一起，是有可能得到一个比单模型更好的融合模型\nQ3：都有哪些模型融合的方法？ A3： 1、Boosting（串行）：【此处应该有图】 2、Bagging（并行）: 【此处应该有图】\nQ4：什么是Boosting？ A4： STEP1. 先从初试训练集训练出一个单模型 STEP2. 根据单模型的表现对训练数据分布进行调整，使得先前单模型做错的样本在后续的训练中得到更多的关注 STEP3. 根据调整后的训练数据训练下一个单模型，返回STEP2，直到训练得到了总共T个单模型 STEP4. T个单模型加权平均\nQ5：什么是Bagging？ A5： STEP1. 采样出T个训练数据集 STEP2. 基于各个采样集单独训练模型 STEP3. 模型融合\nQ6：怎样组合多个单模型？ A6：常用1、平均法，2、投票法，3、学习法（stacking） Q7：什么是模型间的差异性？ A7：模型的多样性（差别有多么的大） Q8：怎样进行差异性的度量？ A8：成对型差异性度量指标，有助于绘图观察：不合度量，相关系数，Q-统计量，k-统计量 Q9：怎样增强模型间的差异性？ A9：有如下几种常用方法：1、数据样本扰动，2、特征扰动，3、输出扰动，4、算法参数扰动 Notes  模型融合中的核心问题：1、怎样训练多个单模型？2、怎样组合多个单模型？ Boosting主要关注降低偏差；Bagging主要关注降低方差； RF中的k同时使用了数据样本扰动和特征扰动两种方式，且k一般取log_2(d), d是特征的维数 不稳定模型（对数据敏感）：决策树、神经网络 稳定模型（对数据不敏感）：SVM、朴素贝叶斯、KNN、线性分类器  ","permalink":"https://hillbamboo.github.io/posts/tech/zzh-ml/","summary":"chapter 2. 模型选择和评估 Q1：什么模型才是好的模型？ A1：泛化能力强的（即泛化误差小的）模型是更好的模型 Q2：怎样知道模型的泛化能力？ A2：思路：将数据集分为训练/验证集，在训练集上训练模型，在验证集上跑模型得到的预测误差近似认为是泛化误差 Q3：具体来说，应该怎样对数据集进行划分？ A3：常用三种划分方法：\n hand-out: 直接按比例划分 k-fold：k折交叉验证，特殊形式：留一法 boostrap sampling: 放回抽样  Q4：如何度量模型的预测误差？（怎样才能判断一个模型表现得更好？） A4：有很多的量化指标可以用来度量模型的误差，常用的有：错误率、正确率、查全率、查准率、F-1、 ROC、AUC、confusion matrix、cost matrix、F-beta、cost-sensitive curve、P-R图、BEP、cost curve等等\n[Notes]\n 过拟合无法避免，我们只能缓解或是降低其发生的风险 训练/验证集要能够充分反映数据的原始规律 在不少的应用任务中，参数调得好不好往往对最终模型性能有着关键性影响 同一算法，不同参数，会产生不同的模型；不同算法，不同参数，会产生更多不同的模型  [Tips]\n 在验证集上进行完了模型选择和调参后，记得要在全体数据集（训练+验证集）上在跑一遍模型 直观理解查全率、查准率、F-1（P30） 记住 bias-varance 平衡的那张图  chapter 3. 线性模型 Q1：什么是线性模型？什么是广义线性模型？ A1：线性模型：形如 y_hat = W_TX+b 广义线性模型：形如 y_hat = g(W_TX+b)\nQ2：怎样从二分类问题推广到多分类问题？ A2：思路：通过组合多个二分类器，得到一个多分类器 具体：\n OVO：对于N个类别，训练 N(N-1)/2 个分类器 OVR：对于N个类别，训练 N 个分类器 MvM: 常用 ECOC技术  Q3：怎样处理类别不平衡问题？ A3：\n 欠抽样（undersampling）: 丢弃样本（但是不能随便丢弃，否则会丢失重要信息） 过抽样（oversampling）: 增加样本（但是不能简单重复，否则会造成过拟合） 阈值移动（threshold-moving）: 再缩放/再平衡  chapter 4. 决策树 Q1：什么是决策树？ A1：形如 【此处应该有图】\nQ2：怎样生成一棵决策树？ A2：不同的算法基于不同的原则，如ID3基于信息增益原则，C4.5基于增益率原则，CART基于基尼指数\nQ3：怎样对决策树进行剪枝？ A3：常用两种剪枝策略： 1、预剪枝：训练时间短，但易于欠拟合 2、后剪枝：训练时间长，但不易欠拟合\nQ4：怎样处理缺失值和连续值？ A4：缺失值：C4.5 连续值：连续变量离散化，常用二分法\nNotes  为了生成一棵决策树，就要合理的选择特征作为一系列的决策变量，为了怎样合理的选择特征这一问题，诞生了一系列的决策树算法 信息增益原则对可取值数目较多的特征有偏好；增益率原则对于可取值数目较少的特征有偏好 决策树决定的决策边界有一个明显的特征：轴平行 单决策树：【此处应该有图】；多变量决策树：【此处应该有图】  chapter 8. 集成学习 Q1：什么是模型融合？ A1： 通过某种方式训练和组合多个模型，最终得到一个总的模型\nQ2：为什么模型融合是可行的？ A2： “好而不同”的单个模型，通过某种有效的方式组合在一起，是有可能得到一个比单模型更好的融合模型\nQ3：都有哪些模型融合的方法？ A3： 1、Boosting（串行）：【此处应该有图】 2、Bagging（并行）: 【此处应该有图】\nQ4：什么是Boosting？ A4： STEP1. 先从初试训练集训练出一个单模型 STEP2. 根据单模型的表现对训练数据分布进行调整，使得先前单模型做错的样本在后续的训练中得到更多的关注 STEP3. 根据调整后的训练数据训练下一个单模型，返回STEP2，直到训练得到了总共T个单模型 STEP4. T个单模型加权平均\nQ5：什么是Bagging？ A5： STEP1. 采样出T个训练数据集 STEP2. 基于各个采样集单独训练模型 STEP3. 模型融合\nQ6：怎样组合多个单模型？ A6：常用1、平均法，2、投票法，3、学习法（stacking） Q7：什么是模型间的差异性？ A7：模型的多样性（差别有多么的大） Q8：怎样进行差异性的度量？ A8：成对型差异性度量指标，有助于绘图观察：不合度量，相关系数，Q-统计量，k-统计量 Q9：怎样增强模型间的差异性？ A9：有如下几种常用方法：1、数据样本扰动，2、特征扰动，3、输出扰动，4、算法参数扰动 Notes  模型融合中的核心问题：1、怎样训练多个单模型？2、怎样组合多个单模型？ Boosting主要关注降低偏差；Bagging主要关注降低方差； RF中的k同时使用了数据样本扰动和特征扰动两种方式，且k一般取log_2(d), d是特征的维数 不稳定模型（对数据敏感）：决策树、神经网络 稳定模型（对数据不敏感）：SVM、朴素贝叶斯、KNN、线性分类器  ","title":"周志华《机器学习》读书笔记"},{"content":"前言 学习Python良久，想全面的回顾一下Python的基础知识，于是阅读了Python3.4的官方教程；在这里做要点的摘录，只为提纲挈领，对细节不做过多的解释。\nControl Flow Tools TODO\nData Structures list, dict, set, tuple, str\nMore on Lists  methods: append(x), extend(L), insert(i, x), remove(x), pop([i]), clear(), index(x), count(x), sort(), reverse(), copy() Using Lists as Stacks(OK) Using Lists as Queues(Not efficient) -\u0026gt; Using collections.deque  Comprehensions List/Set/Dictionary Comprehensions\nLooping Techniques  Using the items() method to loop over dictionaries Using the enumerate() function to loop over a sequence Using the zip() function to loop over two or more sequences at the same time Using the reversed() function to loop over a sequence in reverse Using the sorted() function to loop over a sequence in sorted order  Comparing Sequences and Other Types (1, 2, 3) \u0026lt; (1, 2, 4) [1, 2, 3] \u0026lt; [1, 2, 4] \u0026#39;ABC\u0026#39; \u0026lt; \u0026#39;C\u0026#39; \u0026lt; \u0026#39;Pascal\u0026#39; \u0026lt; \u0026#39;Python\u0026#39; # Comparisons can be chained (1, 2, 3, 4) \u0026lt; (1, 2, 4) (1, 2) \u0026lt; (1, 2, -1) (1, 2, 3) == (1.0, 2.0, 3.0) (1, 2, (\u0026#39;aa\u0026#39;, \u0026#39;ab\u0026#39;)) \u0026lt; (1, 2, (\u0026#39;abc\u0026#39;, \u0026#39;a\u0026#39;), 4) Modules and Packages Input and Output Fancier Output Formatting  The str() function is meant to return representations of values which are fairly human-readable, while repr() is meant to generate representations which can be read by the interpreter  \u0026gt;\u0026gt;\u0026gt; for x in range(1, 11): ... print(repr(x).rjust(2), repr(x*x).rjust(3), end=\u0026#39; \u0026#39;) ... # Note use of \u0026#39;end\u0026#39; on previous line ... print(repr(x*x*x).rjust(4)) ... 1 1 1 2 4 8 3 9 27 4 16 64 5 25 125 6 36 216 7 49 343 8 64 512 9 81 729 10 100 1000 \u0026gt;\u0026gt;\u0026gt; for x in range(1, 11): ... print(\u0026#39;{0:2d}{1:3d}{2:4d}\u0026#39;.format(x, x*x, x*x*x)) ... 1 1 1 2 4 8 3 9 27 4 16 64 5 25 125 6 36 216 7 49 343 8 64 512 9 81 729 10 100 1000  str.format()  \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;We are the {}who say \u0026#34;{}!\u0026#34;\u0026#39;.format(\u0026#39;knights\u0026#39;, \u0026#39;Ni\u0026#39;)) We are the knights who say \u0026#34;Ni!\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;This {food}is {adjective}.\u0026#39;.format( ... food=\u0026#39;spam\u0026#39;, adjective=\u0026#39;absolutely horrible\u0026#39;)) This spam is absolutely horrible. \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;The story of {0}, {1}, and {other}.\u0026#39;.format(\u0026#39;Bill\u0026#39;, \u0026#39;Manfred\u0026#39;,other=\u0026#39;Georg\u0026#39;)) The story of Bill, Manfred, and Georg. \u0026gt;\u0026gt;\u0026gt; table = {\u0026#39;Sjoerd\u0026#39;: 4127, \u0026#39;Jack\u0026#39;: 4098, \u0026#39;Dcab\u0026#39;: 7678} \u0026gt;\u0026gt;\u0026gt; for name, phone in table.items(): ... print(\u0026#39;{0:10}==\u0026gt; {1:10d}\u0026#39;.format(name, phone)) ... Jack ==\u0026gt; 4098 Dcab ==\u0026gt; 7678 Sjoerd ==\u0026gt; 4127 \u0026gt;\u0026gt;\u0026gt; table = {\u0026#39;Sjoerd\u0026#39;: 4127, \u0026#39;Jack\u0026#39;: 4098, \u0026#39;Dcab\u0026#39;: 8637678} \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; \u0026#39; ... \u0026#39;Dcab: {0[Dcab]:d}\u0026#39;.format(table)) Jack: 4098; Sjoerd: 4127; Dcab: 8637678 \u0026gt;\u0026gt;\u0026gt; table = {\u0026#39;Sjoerd\u0026#39;: 4127, \u0026#39;Jack\u0026#39;: 4098, \u0026#39;Dcab\u0026#39;: 8637678} \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}\u0026#39;.format(**table)) Jack: 4098; Sjoerd: 4127; Dcab: 8637678 Class A word About Names and Objects Aliasing has a possibly surprising effect on the semantics of Python code involving mutable objects such as lists, dictionaries, and most other types.\nPython Scopes and Namespaces Odds \u0026amp; Ends class Employee: pass john = Employee() # Create an empty employee record # Fill the fields of the record john.name = \u0026#39;John Doe\u0026#39; john.dept = \u0026#39;computer lab\u0026#39; john.salary = 1000 Iterator \u0026amp; Generator Iterator \u0026gt;\u0026gt;\u0026gt; s = \u0026#39;abc\u0026#39; \u0026gt;\u0026gt;\u0026gt; it = iter(s) \u0026gt;\u0026gt;\u0026gt; it \u0026lt;iterator object at 0x00A1DB50\u0026gt; \u0026gt;\u0026gt;\u0026gt; next(it) \u0026#39;a\u0026#39; \u0026gt;\u0026gt;\u0026gt; next(it) \u0026#39;b\u0026#39; \u0026gt;\u0026gt;\u0026gt; next(it) \u0026#39;c\u0026#39; \u0026gt;\u0026gt;\u0026gt; next(it) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in ? next(it) StopIteration Generator \u0026gt;\u0026gt;\u0026gt; def reverse(data): ... for index in range(len(data)-1, -1, -1): ... yield data[index] \u0026gt;\u0026gt;\u0026gt; for char in reverse(\u0026#39;golf\u0026#39;): ... print(char) ... f l o g Generator Expressions \u0026gt;\u0026gt;\u0026gt; sum(i*i for i in range(10)) # sum of squares 285 \u0026gt;\u0026gt;\u0026gt; xvec = [10, 20, 30] \u0026gt;\u0026gt;\u0026gt; yvec = [7, 5, 3] \u0026gt;\u0026gt;\u0026gt; sum(x*y for x,y in zip(xvec, yvec)) # dot product 260 \u0026gt;\u0026gt;\u0026gt; from math import pi, sin \u0026gt;\u0026gt;\u0026gt; sine_table = {x: sin(x*pi/180) for x in range(0, 91)} \u0026gt;\u0026gt;\u0026gt; unique_words = set(word for line in page for word in line.split()) \u0026gt;\u0026gt;\u0026gt; valedictorian = max((student.gpa, student.name) for student in graduates) \u0026gt;\u0026gt;\u0026gt; data = \u0026#39;golf\u0026#39; \u0026gt;\u0026gt;\u0026gt; list(data[i] for i in range(len(data)-1, -1, -1)) [\u0026#39;f\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;] Brief Tour of Standard Library TODO\nReference The Python Tutorial\n","permalink":"https://hillbamboo.github.io/posts/tech/pydoc01/","summary":"前言 学习Python良久，想全面的回顾一下Python的基础知识，于是阅读了Python3.4的官方教程；在这里做要点的摘录，只为提纲挈领，对细节不做过多的解释。\nControl Flow Tools TODO\nData Structures list, dict, set, tuple, str\nMore on Lists  methods: append(x), extend(L), insert(i, x), remove(x), pop([i]), clear(), index(x), count(x), sort(), reverse(), copy() Using Lists as Stacks(OK) Using Lists as Queues(Not efficient) -\u0026gt; Using collections.deque  Comprehensions List/Set/Dictionary Comprehensions\nLooping Techniques  Using the items() method to loop over dictionaries Using the enumerate() function to loop over a sequence Using the zip() function to loop over two or more sequences at the same time Using the reversed() function to loop over a sequence in reverse Using the sorted() function to loop over a sequence in sorted order  Comparing Sequences and Other Types (1, 2, 3) \u0026lt; (1, 2, 4) [1, 2, 3] \u0026lt; [1, 2, 4] \u0026#39;ABC\u0026#39; \u0026lt; \u0026#39;C\u0026#39; \u0026lt; \u0026#39;Pascal\u0026#39; \u0026lt; \u0026#39;Python\u0026#39; # Comparisons can be chained (1, 2, 3, 4) \u0026lt; (1, 2, 4) (1, 2) \u0026lt; (1, 2, -1) (1, 2, 3) == (1.","title":"Python tutorial 摘录"},{"content":"面向对象 python 并不会自动调用超类的构造函数！需要编程者自己显示的调用\n对象持久化 dump \u0026amp; load #!/usr/bin/python # Filename: pickling.py import cPickle as p #import pickle as p shoplistfile = \u0026#39;shoplist.data\u0026#39; # the name of the file where we will store the objec shoplist = [\u0026#39;apple\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;carrot\u0026#39;] # Write to the file f = open(shoplistfile, \u0026#39;w\u0026#39;) p.dump(shoplist, f) # dump the object to a file f.close() del shoplist # remove the shoplist # Read back from the storage f = open(shoplistfile, \u0026#39;r\u0026#39;) storedlist = p.load(f) print storedlist f.close() 参考资料  a byte of python  ","permalink":"https://hillbamboo.github.io/posts/tech/a-byte-of-pyhton-note-01/","summary":"面向对象 python 并不会自动调用超类的构造函数！需要编程者自己显示的调用\n对象持久化 dump \u0026amp; load #!/usr/bin/python # Filename: pickling.py import cPickle as p #import pickle as p shoplistfile = \u0026#39;shoplist.data\u0026#39; # the name of the file where we will store the objec shoplist = [\u0026#39;apple\u0026#39;, \u0026#39;mango\u0026#39;, \u0026#39;carrot\u0026#39;] # Write to the file f = open(shoplistfile, \u0026#39;w\u0026#39;) p.dump(shoplist, f) # dump the object to a file f.close() del shoplist # remove the shoplist # Read back from the storage f = open(shoplistfile, \u0026#39;r\u0026#39;) storedlist = p.load(f) print storedlist f.close() 参考资料  a byte of python  ","title":"Python对象持久化"},{"content":"面向对象程序设计方法  一切东西都是对象 程序就是一堆对象的集合，他们之间互通信息 每个对象都有自己的存储空间（即“内存资源”） 每一个对象(object)都有一种类型(class) 同一类的所有对象能够相应也响应相同的消息  每个对象都需要“资源”才能生存，其中最重要的一类“资源”，就是内存 内存池 = 内存堆（Heap） 参考书  Grady\tBooch 《Object-Oriented Design with Applications,第2版 本》  ","permalink":"https://hillbamboo.github.io/posts/tech/thinking-in-java-notes-01/","summary":"面向对象程序设计方法  一切东西都是对象 程序就是一堆对象的集合，他们之间互通信息 每个对象都有自己的存储空间（即“内存资源”） 每一个对象(object)都有一种类型(class) 同一类的所有对象能够相应也响应相同的消息  每个对象都需要“资源”才能生存，其中最重要的一类“资源”，就是内存 内存池 = 内存堆（Heap） 参考书  Grady\tBooch 《Object-Oriented Design with Applications,第2版 本》  ","title":"Thinking in Java 笔记 01"},{"content":"对象交互 面向对象的设计思想 看问题域中包含哪些对象，他们之间的交互行为是怎样的 例子：数字时钟\n关于private,public  私有的含义是对于类而言的，而不是对对象来说私有 若一个对象/函数没有private,public的访问属性限制，则这个东东被视为friendly的，即同一个包内的其他对象可以访问这一个这个成员  包  JAVA的类管理是通过文件夹来实现的，简单来说，就是一个文件夹就是一个包，里面的若干个JAVA文件就同属于这个包的。 full name vs. given name  类对象和类函数  简单来说，就是加了static修饰符的对象和函数 类对象和类函数只能被同级对象/函数访问，无法被对象变量/对象函数访问  ","permalink":"https://hillbamboo.github.io/posts/tech/zju-java-notes-01/","summary":"对象交互 面向对象的设计思想 看问题域中包含哪些对象，他们之间的交互行为是怎样的 例子：数字时钟\n关于private,public  私有的含义是对于类而言的，而不是对对象来说私有 若一个对象/函数没有private,public的访问属性限制，则这个东东被视为friendly的，即同一个包内的其他对象可以访问这一个这个成员  包  JAVA的类管理是通过文件夹来实现的，简单来说，就是一个文件夹就是一个包，里面的若干个JAVA文件就同属于这个包的。 full name vs. given name  类对象和类函数  简单来说，就是加了static修饰符的对象和函数 类对象和类函数只能被同级对象/函数访问，无法被对象变量/对象函数访问  ","title":"面向对象程序设计-JAVA 学习笔记01"},{"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start Create a new post $ hexo new \u0026#34;My New Post\u0026#34; More info: Writing\nRun server $ hexo server More info: Server\nGenerate static files $ hexo generate More info: Generating\nDeploy to remote sites $ hexo deploy More info: Deployment\n","permalink":"https://hillbamboo.github.io/posts/tech/hello-world/","summary":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start Create a new post $ hexo new \u0026#34;My New Post\u0026#34; More info: Writing\nRun server $ hexo server More info: Server\nGenerate static files $ hexo generate More info: Generating\nDeploy to remote sites $ hexo deploy More info: Deployment","title":"Hello World"},{"content":"原题描述 旋转链表\n思路 简单题，可使用模拟法。注意处理空链表、k \u0026gt;=链表长度len等边界情况\n/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { ListNode* cur = head; if (cur == nullptr) return 0; int len = 0; while (cur) ++len, cur = cur-\u0026gt;next; int first = (len - (k % len)) % len; if (first == 0) return head; cur = head; for (int i = 0; i \u0026lt; first - 1; ++i) { cur = cur-\u0026gt;next; } ListNode* last = cur-\u0026gt;next; cur-\u0026gt;next = nullptr; ListNode* ans = last; while (last-\u0026gt;next) last = last-\u0026gt;next; last-\u0026gt;next = head; return ans; } }; 运行结果 执行用时：8 ms, 击败82.17%的用户 内存消耗：11.4 MB，超过44.80%的用户 ","permalink":"https://hillbamboo.github.io/posts/tech/leetcode-daily-001/","summary":"原题描述 旋转链表\n思路 简单题，可使用模拟法。注意处理空链表、k \u0026gt;=链表长度len等边界情况\n/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { ListNode* cur = head; if (cur == nullptr) return 0; int len = 0; while (cur) ++len, cur = cur-\u0026gt;next; int first = (len - (k % len)) % len; if (first == 0) return head; cur = head; for (int i = 0; i \u0026lt; first - 1; ++i) { cur = cur-\u0026gt;next; } ListNode* last = cur-\u0026gt;next; cur-\u0026gt;next = nullptr; ListNode* ans = last; while (last-\u0026gt;next) last = last-\u0026gt;next; last-\u0026gt;next = head; return ans; } }; 运行结果 执行用时：8 ms, 击败82.17%的用户 内存消耗：11.4 MB，超过44.80%的用户 ","title":"[Leetcode每日打卡]旋转链表"},{"content":"","permalink":"https://hillbamboo.github.io/about/","summary":"","title":"关于"}]