<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git for Windows 无法显示中文]]></title>
    <url>%2F2019%2F08%2F20%2Fgit-cannot-display-chinese%2F</url>
    <content type="text"><![CDATA[git for windows 无法显示中文，这个问题之前碰到过两次。解决方案如下： 12345git config --global core.quotepath false git config --global gui.encoding utf-8 git config --global i18n.commit.encoding utf-8 git config --global i18n.logoutputencoding utf-8 export LESSCHARSET=utf-8 参考资料 解决 Git 在 windows 下中文乱码的问题]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习常见面试题]]></title>
    <url>%2F2019%2F08%2F14%2Fml-learning-interview%2F</url>
    <content type="text"><![CDATA[0.0.1. Q1: 请简述logit回归？0.0.2. A1: 关键词：线性模型，最大化似然，梯度下降。逻辑回归本质上是一种线性模型，可以看做是线性回归之后套上一个sigmoid函数，不同在于逻辑回归是用于分类。逻辑回归假设数据是服从二项分布的（类似地，多项式回归假设数据服从多项式分布，泊松回归假设数据服从泊松分布，负二项回归假设数据服从负二项分布）。逻辑回归的优化策略是对训练集进行极大似然估计。最小化交叉熵损失等于极大化似然。常用梯度下降进行极大似然估计，当然也可以使用牛顿法等二阶优化方法。逻辑回归的优势在于，简单，快速，可解释性强。模型中每一个特征的系数都对应着该特征的重要程度。推导逻辑回归模型时可能需要向量化，这个也要熟悉一下。]]></content>
      <tags>
        <tag>ml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组: 小而美的数据结构]]></title>
    <url>%2F2019%2F08%2F04%2Fbinary-index-tree%2F</url>
    <content type="text"><![CDATA[1. 问题描述动态前缀和维护问题。给定一个区间 $A[1..n]$, 对该区间进行如下两类操作 (前缀和查询)指定$1 \le j \le n$, 求$A[1..j]$的前缀和 (单点修改)指定$1 \le j \le n$, 令A[j] += val 分析。该问题可以通过前缀数组$arr[1..n]$完成，空间复杂度是$O(n)$, 操作一的时间复杂度是$O(1)$, 操作二的时间是$O(n)$, 最坏情况是$j = n$时整个$arr[1..n]$均需要更新。树状数组能够把操作一和操作二的时间复杂度都降至$O(\log n)$, 空间是$O(n)$. 2. 树状数组树状数组是一类巧妙利用了二进制的数据结构. 在动态前缀和维护问题中，输入$1 \le j \le n$, 若我们能从二进制的观点来看待$j$, 则$j$至多有$\log n$位. 举例, 易知 j = 13_{10} = 1101_{2} = 8 + 4 + 1从而求数组的$A$的前13项之和可以分成三步: A[1..13] = A[1..8] + A[9..12] + A[13]注意区间$A[1..8], A[9..12], A[13]$的区间大小分别就是8, 4, 1, 这对应了13的进制分解. 我们记 c[8] = A[1..8], c[12] = A[9..12], c[13] = A[13]则若我们知道了数组$c[1..n]$, 则前缀和可以在$O(\log n)$时间内完成. 数组$c[1..n]$被称为树状数组. 2.1. 树状数组的含义在此之前, 首先我们来明确一下$c[j]$的含义，他是指以$A[j]$结尾的往前一段区间的和, 为了方便我们称这一段区间为$c[j]$的前缀区间. $c[j]$的前缀区间有多长？如下: \left| c[j] \right| = j\ \&\ (-j)其中符号$\&amp;$表示按位与. 上式的实际意义是指$j$的二进制表示中最右边的1所占的权重. 举例，如$12_{10} = 1100_{2} = 8 + 4, 4 = 12\ \&amp; \ (-12)$, 则$c[12]$的前缀区间长度是4, 同理$\left | c[13] \right | = 1, \left | c[8] \right | = 8, \left | c[2] \right | = 2$. 可以看出规律，凡是$j$是2的幂次形式是$c[j]$的前缀区间长度总是j, 这是因为此时j仅有一个1. 2.2. 前缀和查询首先来考察操作一:前缀和查询操作. 给定$1 \le j \le n$, 怎样使用$c[1..n]$计算得到$A[1..n]$? 仍然以$j = 13$举例, \begin{aligned} A[1..13] & = A[1..8] & + A[9..12] & + A[13] \\ & = c[8] + & c[12] & + c[13] \end{aligned}我们知道 \begin{aligned} 13 & = 1101 + 0 = & 13\\ & = 1100 + 1 = & 12 + 1\\ & = 1000 + 101 = & 8 + (4 + 1) \\ & = 0000 + 1101 = & 0 + 13 \end{aligned}从而我们可以通过反复抹除13的最右边的1来得到不同的$c[k]$, 将这些$c[k]$求和就是$A[1..j]$的值, 这样的$c[k]$总量不超过$\log n$, 从而我们可以在$O(\log n)$时间内完成前缀和查询. 不断抹除最右边的1可以通过j -= (j &amp; -j)实现, 当然，边界条件是j &gt; 0. 前缀和查询的完整代码123456789/// x = 1, 2, ..., nint sum(int x) &#123; int ret = 0; while (x &gt; 0) &#123; ret += c[x]; x -= (x &amp; -x); &#125; return ret;&#125; 作为特例，对于数组$A[1..n]$的单点查询可以通过 $sum(j) - sum(j - 1)$得到$A[j]$. 查询$A$的子区间和$[lo, hi]$可以通过$sum(hi) - sum(lo - 1)$实现. 时间均是 $2 \times O(\log n)$, 渐进阶是$O(\log n)$ 2.3. 单点修改给定$1 \le j \le n$, 置 $A[j] += val$, 显然要修改$c[1..n]$中的某些值以达到动态维护区间的目的。显然$A[j]$变了, $c[j]$一定变，此外，其他所有覆盖了$A[j]$的$c[k]$均需改变，如何找到这些$c[k]$? 更直接一点，如何找了这些$k$? 首先，显然这些$k \ge j$. 首先来考察一个实例$j = 3 = 0011$, 容易知道$c[3]$的前缀区间长度是1, 那么只比$j = 3$大一点点的又恰能覆盖$A[3]$的$k = ?$ 我们首先取出3最右边的1，其权值恰好是$w = 1$, 我们令$4 = 3 + w = 0100$, 其值恰好是$c[4]$, 容易知道$c[4]$是第一个覆盖了$A[3]$的元素，然后下一个$k$怎么求？显然$8 = 0100 + 0100 = 4 + 4$, 我们将4的最右边的1取出，其权值$w = 4$, $c[8]$是覆盖了$c[4]$的一个元素. 从而，我们知道k值得计算是通过j += (j &amp; -j)实现的，边界是j &lt;= n. 再举一个实例，修改$A[13]$，对应应修改的$c[k]$是$c[13], c[14]$. 容易知道这些$c[k]$总量同样不会超过$\log n$个, 从而单点修改可以在$O(\log n)$时间内完成. 单点修改完整代码如下 123456void add(int j, int val) &#123; while (j &lt;= n) &#123; C[j] += val; j += (j &amp; -j); &#125;&#125; 2.4. 构建树状数组有了前两步的操作，构建一个树状数组十分直接 12345init(int* A, int n) &#123; N = n + 1; for (int i = 0; i &lt; N; ++i) c[i] = 0; for (int i = 1 /*注意*/; i &lt; N; ++i) update(i, A[i - 1]);&#125; 3. 总结树状数组$C[1,\cdots,n]$是原数组$A[1,\cdots,n]$的预处理数组，其中包含了原始数组的所有信息。其主要是二进制的思想，即 1.sum(i). 为查询$A[1,\cdots,i]$之和，将$i$转化为二进制数，这样在不超过$\log i$次操作就能将前n个数之和统计出来。其具体实现只需一路沿i -= lowbit(i)计算sum +=C[i]即可,其中$i \gt 0$. 该算法时间是$O(\log n)$ 2.add(i,val).进行$A[i] += val$, 同样将$i$视为二进制数，这样在不超过$\log i$次操作就能实现元素的add操作.其具体实现只需一路沿i += lowbit(i)修改C[i]+=val即可. 其中$i \le n$. 该算法时间是$O(\log n)$ 树状数组的初始化就是首先令$C[1..n]=0$, 然后依次调用add(i, A[i]), i =1,2,...,n. 将下标看做二进制数，正是树状数组（Binary Indexed Tree）名字的由来，其中Binary指的是二进制而不是二叉。 还有一个需要注意的是，树状数组中的$C[i] = Sum(A[i-lowbit(i)+1,\cdots, i])$, 大白话就是$C[i]$是原数组$A$中以$A[i]$结尾（包含）的前$lowbit(i)$个元素之和 树状数组的优势具有以下优势 实现简单 时间常数小 开了一倍空间（zkw树动态维护前缀和需要两倍空间）]]></content>
  </entry>
  <entry>
    <title><![CDATA[三行并查集]]></title>
    <url>%2F2019%2F07%2F29%2Fdisjoin-set%2F</url>
    <content type="text"><![CDATA[1. 三行并查集并查集是一种简洁而优雅的数据结构，能够在O(1)的时间内实现对集合的查询和合并操作。 并查集的代码十分简洁，总共就三行 123Init(n) &#123; for(int i = 0; i &lt; n; ++i) root[i] = i;&#125;Find(x) &#123; return x == root[x] ? x : root[x] = find(root[x]); &#125;Union(x, y) &#123;root[find(x)] = find(y); &#125; 其中root[i]表示元素i的父节点 2. 路径压缩注意Find函数中使用的是递归调用, 其中将递归调用后得返回值重新赋值给root[x], 这是做法称为 路径压缩, 为了防止反复对集合进行合并后并查集退化成一条链，从而时间复杂度退化成线性时间所做的优化，注意无路径压缩的写法如下 1x == root[x] ? x : find(root[x]) 这c/c++用这种写法很OK，但是用python写，最少都要用两行 12if root[x] != x: root[x] = find(root[x])return root[x] 用下面的这种写法是不行的:1return x if root[x] == x else root[x] = find(root[x]) 此外，路径压缩自然可以改写成非递归形式，做法很简单，下文略。 3. 按秩归并Union操作还可以进行按秩归并的优化. 首先介绍集合的rank的概念。 在并查集中，一个集合用一棵树表示，这棵树的深度就是该集合的rank，树越深rank越大. 容易知道rank越低find操作越高效，这也是路径压缩所追求的。按秩归并的思路是将rank低的集合并入到rank高的集合，这样可以延缓并查集变成一条链的情形，从而提高Find的效率. 若不是将小rank集合归如大rank结合，合并后的新集合的rank总会增长，最终rank=集合元素个数时，find操作是线性的。注意，为了实现按秩归并，我们仅需要多维护一个rank数组即可，足够简单。 加上了按秩归并优化的Union函数长成下面这个样子 1234567void Union(x, y) &#123; int xr = find(x), yr = find(y); if (rank[xr] &lt;= rank[yr]) &#123; root[xr] = yr; if (rank[xr] == rank[yr]) ++rank[yr]; &#125; else root[yr] = xr; 按秩归并算法多了几行，为了偷懒有时随便Union也OK. 不超时就好. 讲究一点的就按秩归并吧. 4. 练习题 leetcode 200 leetcode 547 leetcode 684 leetcode 959 leetcode 990 5. 后续可持久化并查集？等我学会了再写吧~~~]]></content>
      <tags>
        <tag>algos, data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划初步]]></title>
    <url>%2F2019%2F07%2F20%2Fdp-basic%2F</url>
    <content type="text"><![CDATA[How should I explain dynamic programming to a 4 year old? writes down “1+1+1+1+1+1+1+1 =” on a sheet of paper* “What’s that equal to?” (counting…) “Eight!” writes down another “1+” on the left* “What about that?” (quickly…) “Nine!” “How’d you know it was nine so fast?” “You just added one more” “So you didn’t need to recount because you remembered there &gt; were eight! Dynamic Programming is just a fancy way to say &gt; ‘remembering stuff to save time later’” 三大算法思路: 搜索，贪心，dp，分治 fib数列青蛙跳变态青蛙跳挖金矿花瓶美学数字三角形背包九问最长公共子序列单源最短路径问题 当你企图使用计算机解决一个问题是，其实就是在思考如何将这个问题表达成状态（用哪些变量存储哪些数据）以及如何在状态中转移（怎样根据一些变量计算出另一些变量）。所以所谓的空间复杂度就是为了支持你的计算所必需存储的状态最多有多少，所谓时间复杂度就是从初始状态到达最终状态中间需要多少步！ 每个阶段只有一个状态-&gt;递推 每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心 每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。 三要素 最优子结构 状态转移方程 边界 四步走 划分阶段 确定状态 寻找最优子结构 (从特例出发考虑最优子结构) 考虑最优子结构的一般情况，注意考虑周全 写出状态转移方程和边界情况(平凡/退化情况), 注意边界不要写漏 三步走 划分阶段 考虑平凡情况，如当数组长度为0时 考虑一般情况， 如规模为i的问题已解决，如何基于此求解规模为i+1的问题 1-&gt;2-&gt;3-&gt;4, 1-&gt;4-&gt;2-&gt;3 1. 参考资源 How should I explain dynamic programming to a 4-year-old? 知乎 知乎 知乎]]></content>
      <tags>
        <tag>algos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习算法: 朴素贝叶斯篇]]></title>
    <url>%2F2019%2F07%2F17%2Fnaive-bayes%2F</url>
    <content type="text"><![CDATA[朴素贝叶斯是一类很简单的分类算法, 应用场景较多, 如垃圾邮件分类, 输入法中的拼写检查, 文本情感分类等等. 初学朴素贝叶斯时被”朴素”二字迷惑, 认为之所以称之为 “朴素” 时因为算法很 “简单”, 很naive. 实际上, “朴素” 更准确的含义是（特征间的）条件独立性假设, 由于这一假设使得这个算法很 “naive”, 他的引入是为了简化后验概率的计算. 学习算法不能走马观花, 浅尝辄止, 还是得花时间好好琢磨. 1. 贝叶斯公式先补充贝叶斯公式作为预备知识.贝叶斯公式形如下式： 其中$\mathbb{x}$表示样本, $c$表示类别, 贝叶斯公式给出了样本与类别之间的生成关系.更通俗地讲, 假设给定未知样本$\mathbb{x}$, $c$的可能取值是 ${0, 1, 2, \cdots, k}$, 则概率 Pr(c=j|\mathbb{x}) = \frac{Pr(\mathbb{x}|c=j) \times Pr(c = j)}{Pr(\mathbb{x})}, \ j=0, 1, \cdots, k2. 朴素贝叶斯算法朴素贝叶斯模型是一类生成模型, 它的生成关系有贝叶斯公式给出, 模型的训练是通过最大化后验概率实现的. 2.1. 模型假设朴素贝叶斯算法的前提假设是特征之间的条件独立性, 即：给定样本$\mathbb{x}=(x_1, x_2, \cdots, x_n)$, 其中$x_i$为第$i$个特征, 则 Pr(\mathbb{x}|c=j) = Pr(c=j) \times \prod\limits_{i}Pr(x_i|c=j)2.2. 算法推导由贝叶斯公式可知 Pr(c=j|\mathbb{x}) = \frac{Pr(\mathbb{x}|c=j) \times Pr(c = j)}{Pr(\mathbb{x})}, \ j=0, 1, \cdots, k由于对于同一个样本, $Pr(\mathbb{x})$取值总是相同的, 从而 \begin{aligned} j^{*} &= \mathop{\arg\max}\limits_{j} \frac{Pr(c = j) \times \prod\limits_{i}Pr(x_i|c = j)}{Pr(\mathbb{x})} \\ & = \mathop{\arg\max}\limits_{j} Pr(c = j) \times \prod\limits_{i}Pr(x_i|c = j) \end{aligned}其中, $j^{*}$即为样本$\mathbb{x}$的预测类别 2.3. 算法流程朴素贝叶斯算法的训练过程就是一个”计数”过程. 具体来说, 它对训练集统计下列两类概率 先验概率（类概率） Pr(c = j) = \frac{\left| D_{c=j}\right|}{\left| D\right|}, 其中 $\left| D_{c=j}\right|$ 为数据集中的类别 $j$所占的数目, $\left| D\right|$为数据集的大小 条件概率（似然） Pr(x_i|c = j) = \begin{cases} \frac{\left| D_{x_i, c=j} \right| }{\left| D_{c} \right| }, & 若\ x\ 离散, \\ \frac{1}{\sigma \sqrt{2\pi}}\cdot \exp\left( -\frac{\left( x_i - \mu\right)^2}{2\sigma^2}\right), & 若\ x\ 连续, \end{cases}其中$\left| D_{x_i, c=j} \right|$为类别是$j$且取值为$x_i$的样本数量. $\mu, \sigma$分别是特征$x_i$的均值与方差 朴素贝叶斯算法的整体流程如下图所示: 2.4. 注意项 条件概率连乘积下溢. 若特征数量很多, 则 \prod\limits_{i}Pr(x_i|c=j)越接近0. 这种现象称为乘法下溢. 为改进之, 可使用对数似然, 即计算 LL\left( \mathbb{x}|c= j\right) = \log(Pr(c=j)) + \sum\limits_{i}\log(Pr(x_i|c=j)) 未登录词. 若带预测样本中出现了训练集中从未出现过的特征取值, 则后验概率总为0, 为了克服这一点, 可以引入拉普拉斯平滑, 即计算 \hat {Pr}(c = j) = \frac{\left| D_{c=j}\right| + \lambda}{\left| D\right| + N_j \cdot \lambda} \\ \hat {Pr}(\mathbb{x}) = \frac{\left| D_{x_i, c=j} \right| + \lambda}{\left| D_{c} \right| + N_{i} \cdot \lambda}其中, $N_j$为类别$j$的数量, $N_{i}$为特征$x_i$的可能取值数目, $\lambda$为大于0的常数, 常取值为1 3. 总结 朴素贝叶斯算法的主要优点： 对小规模的数据表现很好, 能个处理多分类任务, 适合增量式训练, 尤其是数据量超出内存时, 我们可以一批批的去增量训练. 对缺失数据不太敏感, 常用于文本分类 不受特征尺度的影响, 由于训练过程就是计数的过程, 从而无需归一化等操作 朴素贝叶斯的主要缺点： 需要知道先验概率, 且先验概率很多时候取决于假设, 假设的模型可以有很多种, 因此在某些时候会由于假设的先验模型的原因导致预测效果不佳 由于我们是通过先验和数据来决定后验的概率从而决定分类, 所以分类决策存在一定的错误率 使用朴素贝叶斯算法时的注意点： 贝叶斯分类器与一般意义上的”贝叶斯学习”不同, 前者是通过最大后验概率进行单点估计, 后者是进行分布估计 没有平滑之前的朴素贝叶斯算法使用的是极大似然估计, 属于频率派, 平滑之后的进行的是贝叶斯估计, 属于贝叶斯学派 使用对数似然和拉普拉斯平滑是两种不错的改进方式 4. 参考资源 周志华, 机器学习 朴素贝叶斯算法原理小结 算法杂货铺——分类算法之朴素贝叶斯分类(Naive Bayesian classification)]]></content>
      <tags>
        <tag>ml, algos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[learn-xgb]]></title>
    <url>%2F2019%2F06%2F01%2Flearn-xgb%2F</url>
    <content type="text"><![CDATA[GBDT是一个加法模型，其基模型是决策树，所以名字中带着DT，使用的优化方式是梯度提升，所以名字中带有GB. GDBT类模型如xgb, lgb, catboost, thunderboost都是GBDT的改进版本 0.1. 基本推导GBDT的基本形式： 0.2. XGB J^{(t-1)} = \sum_{j \in T}\left[\left( \sum_{i \in I_j} g_i\right)w_j + \frac{1}{2}\left(\sum_{i \in I_j}h_i + \lambda \right)w_j^2 \right] + \gamma T \\ = \sum_{j \in T}\left[G_jw_j + \frac{1}{2}\left(H_j + \lambda \right)w_j^2 \right] + \gamma T其中 G_j 是落入第\(j\)个叶节点的样本一阶梯度之和， H_j 是落入第\(j\)个叶节点的样本的二阶梯度之和，对于式 G_jw_j + \frac{1}{2}\left(H_j + \lambda \right)w_j^2w_j相当于自变量 x从而 w_j = -\frac{G_i}{H_j + \lambda}$$ 时该式取得最小值，将其带入目标函数中，得到 $$J^{(t)} = -\frac{1}{2}\sum_{j=1, \cdots , T}\frac{G_j^2}{H_j + \lambda} + \gamma T0.3. 参考资料 GBDT的原理和应用]]></content>
  </entry>
  <entry>
    <title><![CDATA[Jupyterlab交互式环境配置]]></title>
    <url>%2F2019%2F05%2F30%2Fsetup-jupyterlab-interactive-computational-envs%2F</url>
    <content type="text"><![CDATA[1. 安装jupyter notebook 插件 table of content 用于为长文本生成目录 一些color scheme, background image 之类 2. 安装jupyter lab 为jupyter lab 安装插件 pixiedust: IBM的notebook debugger 安装 jupyterlab-variableInspector 用于更快捷地观察变量, 妈妈再也不用担心我整天print变量了]]></content>
  </entry>
  <entry>
    <title><![CDATA[剑指offter读书笔记]]></title>
    <url>%2F2019%2F03%2F03%2Fsword-to-offer%2F</url>
    <content type="text"><![CDATA[1. 面试流程 电话面试 远程面试 现场面试 在电话面试中，要用尽可能简洁和形象化的语言讲述问题； 在远程面试中，重点考察的是编码的能力，要注意以下三点： 想清楚再写 使用单元测试 注意代码风格在编码之前，应该先写写单元测试（或构造一些边界情况） 现场面应该注意： 提前规划好路线及估算好时间，预留30min作缓冲 提前追备好几个问题问面试官 2. 一场面试中的环节 自我介绍 (30s - 1min) 项目经历 (5min - 10min) 技术考察 (40min - 50min) 应聘者提问 (~5min) 2.1. 自我介绍暖场用 2.2. 项目经历建议使用以下的框架讲述自己的项目经历 Situation (简述项目的背景，如规模，功能，目标群体等等) Task (已完成的任务，注意用词：参与 vs 负责) Action (做了什么工作，怎么做的) Result (自己的贡献，完成了多少的功能，做了多少的优化，提升了多少的功能) 常见套路： 项目中遇到的最大的问题是什么？如何克服的？ 从这个项目中学到了什么？ 团队协作中遇到过什么问题？如何解决的？ 为什么跳槽/为什么选择与本专业不同的职业？ 回答为什么跳槽这类的问题，模板：在原来的工作岗位上没有了激情，寻求新环境改变、提升自己. 比如说自己在原工作上做了好多年，技能上没有了上升的空间，寻找一家新的公司获得提升. 2.3. 技术考察通常是题目的考察。一定要注意，在写代码之前先和面试官沟通好，明确题意是什么，再讲述自己的解题思路，还要说说自己构造的测试用例，体现自己思考问题的严谨性与全面性。 2.4. 应聘者提问不要问什么公司未来的发展战略的问题，作为一线的开发者，问问关于自身岗位的问题，也不要去谈薪资，谈你是否会给我offer之类的问题. 3. 面试能力的考察 沟通能力 学习能力 在沟通能力中，常见的套路是面试官提出一个描述并不清楚的问题，试图让面试者通过反复的沟通理解题意。从而，面试者要有主动沟通的意识在考察学习能力方面，常见的两个套路：1. 最近在看什么书或项目？2. 试图让面试者解决他所不熟悉的领域问题，或者一个新概念，让面试者试图解决问题。沟通能力和学习能力的考察常常交织在一起，要注意灵活应对。 4. 总结 主动沟通意识 想清楚再写 先和面试官讲清楚解题的思路 进行单元测试 5. 参考资料 何海涛. 剑指offer第二版]]></content>
  </entry>
  <entry>
    <title><![CDATA[堆与堆排序]]></title>
    <url>%2F2019%2F02%2F27%2Fheap-heapsort%2F</url>
    <content type="text"><![CDATA[作为三大经典排序算法的堆排序，借助了堆这种精巧的数据结构，实现了排序. 理解了堆结构，再理解堆排序就不难了. 堆排序中三点要重点掌握： 怎样通过下标找到节点的父节点及子节点 建堆算法 堆调整算法 1. 什么是堆堆是一种数据结构，能够支持高效的操作.堆得一种经典实现是使用完全二叉树，这种实现也被称为完全二叉堆.事实上，堆的树结构只是它的一种逻辑结构，也就是画在纸的，在我们脑海中想象出来的，实际内存中的物理结构，常常是使用数组. 有时候堆也被称为优先级队列，这是它的逻辑上的名字，别人用起来就好像是这种结构具有某种优先级.一般来说，堆分两种: 大根堆和小根堆.作为一种数据结构，考察堆的增删改查操作.修改在堆中并不常见，忽略. 查找操作也只限定在查找最大值/最小值上. 增加操作通常加在堆的最后，删除操作通常删除根节点. 2. 堆与数组的转化堆结构和数组具有很好的对应，即给定一个规模为n的二叉堆，给堆得层序遍历序列对应的就是一个数组，大小同样为n. 从而，有了一个数组，就能把这个数组当成堆来用.使用三个公式即可找到任意节点i的父节点，左节点和右节点（如果有的话）. 假设大小为n的数组arr，下标记为$i = 0, 1, \cdots, n - 1$, 则其左节点的下标为 $2 \cdot i + 1$, 其右节点（如果有）的下标为 $2 \cdot i + 2$, 对于下标为j的节点，其父节点的下标为 $(j - 1) / 2$, 注意当$j = 0$ 时 其父节点时自身，$(0 - 1) / 2 = 0$ 不会越界. 3. 建堆与维护堆堆中，最重要的两种操作是：建堆和维护堆.建堆是指给定一组数据，比如就是一个数组，通过某种算法将其调整为一个堆（调整操作也就是调整数组中元素的位置）；维护堆是指当增删后的堆不再是一个堆时，用某种算法将其再次调整为一个合法的堆.一个合法的堆是指该堆满足堆序性，对于大根堆，堆序性是指根节点是堆中最大值，对于小根堆，定义类似. 已知对于一棵高度为h的满二叉树，其规模$n = 2^{(h + 1)}- 1$, 即 $h = O(\log n)$， 下面讨论建堆算法和堆调整算法. 3.1. 建堆3.1.1. 最开始的思路任意给定一个大小为n的数组，从零位置的元素出发，即从空堆出发，不断将新元素加入堆中，堆的增加操作复杂度为O(logn), 从而要建立一个大小为n的堆，复杂度为： \log 1 + \log 2 + ... + \log n = O(n\log n)更细致的复杂度分析，假定一个规模为n的堆高度是h, 则该堆中第i层的节点个数是2^i, 其中 0 &lt;= i &lt; h, 建堆需要每一个元素i都上溯，则复杂度： 1 \cdot 2^1 + 2 \cdot 2^2 + ... + h \cdot 2^h = O(n \log n)3.1.2. Floyd算法算法一过于复杂，建堆就需要O(nlogn)，还不如使用快排或归排.我们需要一个更高效的算法. 从相反的思路考虑，假设堆已经建好了，我们需要做的是调整堆，即下沉操作.时间复杂度： (h - 1) \cdot 2^1 + (h - 2) \cdot 2^2 + ... + (h - h) \cdot 2^h = O(n)Done! 3.2. 维护堆堆的维护发生在增加或删除操作之后. 对于增加操作，新元素被添加至树的最后一层，最坏情况下该元素需要O(logn)次操作上溯至根节点的位置，才能保证对的合法性；对于删除操作，根节点被删除，堆的最后一个节点被移至根节点的位置，最多需要O(logn)次操作下沉至最后一层，才能保证新堆的合法性. 综上，堆的调整算法复杂度是O(logn). 4. 堆排序有了堆结构，排序就变得很简单了.只需O(1)的辅助空间，O(nlogn)的时间就能实排序.给定一个无序数组，该数组被看作是 [堆(无序区) | 有序区]， 堆排序的过程就是不断交换无序区中的首尾元素（等效于弹出最大值，然后用末元素顶替根元素）， 由此堆不再合法，调用调整算法使其重新称为一个合法堆， 此番操作后有序区扩大，无序区收缩，反复这个过程，遇到空堆时算法终止· 复杂度分析: 堆中n个元素都历经交换和堆调整算法，耗时O(logn)，从而最终复杂度为 O(nlogn).]]></content>
      <tags>
        <tag>algos, data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周志华《机器学习》读书笔记]]></title>
    <url>%2F2018%2F03%2F04%2Fzzh-ML%2F</url>
    <content type="text"><![CDATA[1. chapter 2. 模型选择和评估1.0.1. Q1：什么模型才是好的模型？1.0.2. A1：泛化能力强的（即泛化误差小的）模型是更好的模型1.0.3. Q2：怎样知道模型的泛化能力？1.0.4. A2：思路：将数据集分为训练/验证集，在训练集上训练模型，在验证集上跑模型得到的预测误差近似认为是泛化误差1.0.5. Q3：具体来说，应该怎样对数据集进行划分？A3：常用三种划分方法： hand-out: 直接按比例划分 k-fold：k折交叉验证，特殊形式：留一法 boostrap sampling: 放回抽样 1.0.6. Q4：如何度量模型的预测误差？（怎样才能判断一个模型表现得更好？）A4：有很多的量化指标可以用来度量模型的误差，常用的有：错误率、正确率、查全率、查准率、F-1、ROC、AUC、confusion matrix、cost matrix、F-beta、cost-sensitive curve、P-R图、BEP、cost curve等等 [Notes] 过拟合无法避免，我们只能缓解或是降低其发生的风险 训练/验证集要能够充分反映数据的原始规律 在不少的应用任务中，参数调得好不好往往对最终模型性能有着关键性影响 同一算法，不同参数，会产生不同的模型；不同算法，不同参数，会产生更多不同的模型 [Tips] 在验证集上进行完了模型选择和调参后，记得要在全体数据集（训练+验证集）上在跑一遍模型 直观理解查全率、查准率、F-1（P30） 记住 bias-varance 平衡的那张图 2. chapter 3. 线性模型2.0.1. Q1：什么是线性模型？什么是广义线性模型？A1：线性模型：形如 y_hat = W_TX+b广义线性模型：形如 y_hat = g(W_TX+b) 2.0.2. Q2：怎样从二分类问题推广到多分类问题？A2：思路：通过组合多个二分类器，得到一个多分类器具体： OVO：对于N个类别，训练 N(N-1)/2 个分类器 OVR：对于N个类别，训练 N 个分类器 MvM: 常用 ECOC技术 2.0.3. Q3：怎样处理类别不平衡问题？A3： 欠抽样（undersampling）: 丢弃样本（但是不能随便丢弃，否则会丢失重要信息） 过抽样（oversampling）: 增加样本（但是不能简单重复，否则会造成过拟合） 阈值移动（threshold-moving）: 再缩放/再平衡 3. chapter 4. 决策树3.0.1. Q1：什么是决策树？A1：形如 【此处应该有图】 3.0.2. Q2：怎样生成一棵决策树？A2：不同的算法基于不同的原则，如ID3基于信息增益原则，C4.5基于增益率原则，CART基于基尼指数 3.0.3. Q3：怎样对决策树进行剪枝？A3：常用两种剪枝策略：1、预剪枝：训练时间短，但易于欠拟合2、后剪枝：训练时间长，但不易欠拟合 3.0.4. Q4：怎样处理缺失值和连续值？A4：缺失值：C4.5连续值：连续变量离散化，常用二分法 3.1. Notes 为了生成一棵决策树，就要合理的选择特征作为一系列的决策变量，为了怎样合理的选择特征这一问题，诞生了一系列的决策树算法 信息增益原则对可取值数目较多的特征有偏好；增益率原则对于可取值数目较少的特征有偏好 决策树决定的决策边界有一个明显的特征：轴平行 单决策树：【此处应该有图】；多变量决策树：【此处应该有图】 4. chapter 8. 集成学习4.0.1. Q1：什么是模型融合？4.0.2. A1：通过某种方式训练和组合多个模型，最终得到一个总的模型 4.0.3. Q2：为什么模型融合是可行的？4.0.4. A2：“好而不同”的单个模型，通过某种有效的方式组合在一起，是有可能得到一个比单模型更好的融合模型 4.0.5. Q3：都有哪些模型融合的方法？4.0.6. A3：1、Boosting（串行）：【此处应该有图】2、Bagging（并行）: 【此处应该有图】 4.0.7. Q4：什么是Boosting？4.0.8. A4：STEP1. 先从初试训练集训练出一个单模型STEP2. 根据单模型的表现对训练数据分布进行调整，使得先前单模型做错的样本在后续的训练中得到更多的关注STEP3. 根据调整后的训练数据训练下一个单模型，返回STEP2，直到训练得到了总共T个单模型STEP4. T个单模型加权平均 4.0.9. Q5：什么是Bagging？4.0.10. A5：STEP1. 采样出T个训练数据集STEP2. 基于各个采样集单独训练模型STEP3. 模型融合 4.0.11. Q6：怎样组合多个单模型？4.0.12. A6：常用1、平均法，2、投票法，3、学习法（stacking）4.0.13. Q7：什么是模型间的差异性？4.0.14. A7：模型的多样性（差别有多么的大）4.0.15. Q8：怎样进行差异性的度量？4.0.16. A8：成对型差异性度量指标，有助于绘图观察：不合度量，相关系数，Q-统计量，k-统计量4.0.17. Q9：怎样增强模型间的差异性？4.0.18. A9：有如下几种常用方法：1、数据样本扰动，2、特征扰动，3、输出扰动，4、算法参数扰动4.1. Notes 模型融合中的核心问题：1、怎样训练多个单模型？2、怎样组合多个单模型？ Boosting主要关注降低偏差；Bagging主要关注降低方差； RF中的k同时使用了数据样本扰动和特征扰动两种方式，且k一般取log_2(d), d是特征的维数 不稳定模型（对数据敏感）：决策树、神经网络稳定模型（对数据不敏感）：SVM、朴素贝叶斯、KNN、线性分类器]]></content>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随便想想]]></title>
    <url>%2F2017%2F05%2F23%2Fidea001%2F</url>
    <content type="text"><![CDATA[学习一门编程语言的步骤： 语法规则，数据结构，控制结构 库 大量的编程实践 源码 其中1为入门，2、3为进阶，4为高阶]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python tutorial 摘录]]></title>
    <url>%2F2017%2F05%2F22%2Fpydoc01%2F</url>
    <content type="text"><![CDATA[0.1. 前言学习Python良久，想全面的回顾一下Python的基础知识，于是阅读了Python3.4的官方教程；在这里做要点的摘录，只为提纲挈领，对细节不做过多的解释。 0.2. Control Flow Tools坑 0.3. Data Structureslist, dict, set, tuple, str 0.3.1. More on Lists methods:append(x), extend(L), insert(i, x), remove(x), pop([i]), clear(), index(x), count(x), sort(), reverse(), copy() Using Lists as Stacks(OK) Using Lists as Queues(Not efficient) -&gt; Using collections.deque 0.3.2. ComprehensionsList/Set/Dictionary Comprehensions 0.3.3. Looping Techniques Using the items() method to loop over dictionaries Using the enumerate() function to loop over a sequence Using the zip() function to loop over two or more sequences at the same time Using the reversed() function to loop over a sequence in reverse Using the sorted() function to loop over a sequence in sorted order 0.3.4. Comparing Sequences and Other Types1234567(1, 2, 3) &lt; (1, 2, 4)[1, 2, 3] &lt; [1, 2, 4]'ABC' &lt; 'C' &lt; 'Pascal' &lt; 'Python' # Comparisons can be chained(1, 2, 3, 4) &lt; (1, 2, 4)(1, 2) &lt; (1, 2, -1)(1, 2, 3) == (1.0, 2.0, 3.0)(1, 2, ('aa', 'ab')) &lt; (1, 2, ('abc', 'a'), 4) 0.4. Modules and Packages0.5. Input and Output0.5.1. Fancier Output Formatting The str() function is meant to return representations of values which are fairly human-readable, while repr() is meant to generate representations which can be read by the interpreter 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; for x in range(1, 11):... print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')... # Note use of 'end' on previous line... print(repr(x*x*x).rjust(4))... 1 1 1 2 4 8 3 9 27 4 16 64 5 25 125 6 36 216 7 49 343 8 64 512 9 81 72910 100 1000&gt;&gt;&gt; for x in range(1, 11):... print('&#123;0:2d&#125; &#123;1:3d&#125; &#123;2:4d&#125;'.format(x, x*x, x*x*x))... 1 1 1 2 4 8 3 9 27 4 16 64 5 25 125 6 36 216 7 49 343 8 64 512 9 81 72910 100 1000 str.format()1234567891011121314151617181920212223242526&gt;&gt;&gt; print('We are the &#123;&#125; who say "&#123;&#125;!"'.format('knights', 'Ni'))We are the knights who say "Ni!"&gt;&gt;&gt; print('This &#123;food&#125; is &#123;adjective&#125;.'.format(... food='spam', adjective='absolutely horrible'))This spam is absolutely horrible.&gt;&gt;&gt; print('The story of &#123;0&#125;, &#123;1&#125;, and &#123;other&#125;.'.format('Bill', 'Manfred',other='Georg'))The story of Bill, Manfred, and Georg.&gt;&gt;&gt; table = &#123;'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678&#125;&gt;&gt;&gt; for name, phone in table.items():... print('&#123;0:10&#125; ==&gt; &#123;1:10d&#125;'.format(name, phone))...Jack ==&gt; 4098Dcab ==&gt; 7678Sjoerd ==&gt; 4127&gt;&gt;&gt; table = &#123;'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678&#125;&gt;&gt;&gt; print('Jack: &#123;0[Jack]:d&#125;; Sjoerd: &#123;0[Sjoerd]:d&#125;; '... 'Dcab: &#123;0[Dcab]:d&#125;'.format(table))Jack: 4098; Sjoerd: 4127; Dcab: 8637678&gt;&gt;&gt; table = &#123;'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678&#125;&gt;&gt;&gt; print('Jack: &#123;Jack:d&#125;; Sjoerd: &#123;Sjoerd:d&#125;; Dcab: &#123;Dcab:d&#125;'.format(**table))Jack: 4098; Sjoerd: 4127; Dcab: 8637678 0.6. Class0.6.1. A word About Names and ObjectsAliasing has a possibly surprising effect on the semantics of Python code involving mutable objects such as lists, dictionaries, and most other types. 0.6.2. Python Scopes and Namespaces0.6.3. Odds &amp; Ends123456789class Employee: passjohn = Employee() # Create an empty employee record# Fill the fields of the recordjohn.name = 'John Doe'john.dept = 'computer lab'john.salary = 1000 0.6.4. Iterator &amp; Generator0.6.4.1. Iterator123456789101112131415&gt;&gt;&gt; s = 'abc'&gt;&gt;&gt; it = iter(s)&gt;&gt;&gt; it&lt;iterator object at 0x00A1DB50&gt;&gt;&gt;&gt; next(it)'a'&gt;&gt;&gt; next(it)'b'&gt;&gt;&gt; next(it)'c'&gt;&gt;&gt; next(it)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in ? next(it)StopIteration 0.6.4.2. Generator12345678910&gt;&gt;&gt; def reverse(data):... for index in range(len(data)-1, -1, -1):... yield data[index]&gt;&gt;&gt; for char in reverse('golf'):... print(char)...flog 0.6.4.3. Generator Expressions123456789101112131415161718&gt;&gt;&gt; sum(i*i for i in range(10)) # sum of squares285&gt;&gt;&gt; xvec = [10, 20, 30]&gt;&gt;&gt; yvec = [7, 5, 3]&gt;&gt;&gt; sum(x*y for x,y in zip(xvec, yvec)) # dot product260&gt;&gt;&gt; from math import pi, sin&gt;&gt;&gt; sine_table = &#123;x: sin(x*pi/180) for x in range(0, 91)&#125;&gt;&gt;&gt; unique_words = set(word for line in page for word in line.split())&gt;&gt;&gt; valedictorian = max((student.gpa, student.name) for student in graduates)&gt;&gt;&gt; data = 'golf'&gt;&gt;&gt; list(data[i] for i in range(len(data)-1, -1, -1))['f', 'l', 'o', 'g'] 0.7. Brief Tour of Standard Library坑 0.8. ReferenceThe Python Tutorial]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python对象持久化]]></title>
    <url>%2F2017%2F05%2F16%2Fa-byte-of-pyhton-note-01%2F</url>
    <content type="text"><![CDATA[1. 面向对象 python 并不会自动调用超类的构造函数！需要编程者自己显示的调用 2. 对象持久化2.1. dump &amp; load12345678910111213141516171819#!/usr/bin/python# Filename: pickling.pyimport cPickle as p#import pickle as pshoplistfile = 'shoplist.data' # the name of the file where we will store the objecshoplist = ['apple', 'mango', 'carrot']# Write to the filef = open(shoplistfile, 'w')p.dump(shoplist, f) # dump the object to a filef.close()del shoplist # remove the shoplist# Read back from the storagef = open(shoplistfile, 'r')storedlist = p.load(f)print storedlistf.close() 3. 参考资料 a byte of python]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thinking in Java 笔记 01]]></title>
    <url>%2F2017%2F05%2F13%2Fthinking-in-java-notes-01%2F</url>
    <content type="text"><![CDATA[1. 面向对象程序设计方法 一切东西都是对象 程序就是一堆对象的集合，他们之间互通信息 每个对象都有自己的存储空间（即“内存资源”） 每一个对象(object)都有一种类型(class) 同一类的所有对象能够相应也响应相同的消息 2. 每个对象都需要“资源”才能生存，其中最重要的一类“资源”，就是内存3. 内存池 = 内存堆（Heap）4. 参考书 Grady Booch 《Object-Oriented Design with Applications,第2版本》]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thu-java-notes-03]]></title>
    <url>%2F2017%2F05%2F13%2Fthu-java-notes-03%2F</url>
    <content type="text"><![CDATA[1. 类的复用1.1. 隐藏和覆盖 必须覆盖 不能覆盖+ 1.1.1. 相等和同一 相等（equals） 同一（identical）]]></content>
  </entry>
  <entry>
    <title><![CDATA[thu-java-notes-02]]></title>
    <url>%2F2017%2F05%2F13%2Fthu-java-notes-02%2F</url>
    <content type="text"><![CDATA[1. 类的访问权限控制 public protected friendly同一个包中可访问 private]]></content>
  </entry>
  <entry>
    <title><![CDATA[thu-intro-notes-01]]></title>
    <url>%2F2017%2F05%2F03%2Fthu-intro-notes-01%2F</url>
    <content type="text"><![CDATA[1. 电磁学 场：现代物理学核心概念（法拉第首先提出），场的概念可以类比于水流速度场（通量，环量） 场量的数学描述： 闭合曲面的通量 闭合曲线的环量 学习电磁学，重点要关注电磁场的性质 2. 电路抽象 基本概念： 电压是电场的空间离散化抽象 电流是磁场的空间离散化抽象 电路分析是一大类电磁场分析的空间离散化近似 电路的基本问题：信号与系统的相互作用关系 基本元件：电阻/电导、电容、电感、电源 基本功能电路 基本原理 基本分析方法 基本概念]]></content>
  </entry>
  <entry>
    <title><![CDATA[thu-java-notes-01]]></title>
    <url>%2F2017%2F05%2F03%2Fthu-java-notes-01%2F</url>
    <content type="text"><![CDATA[1. 面向对象基本特征2. 抽象： 只关注有关方面 忽略无关方面 3. 封装： 信息隐藏技术4. 继承： 通过旧类产生新类的机制5. 多态： 不同对象面对同一现象的不同反应 6. java 运行流程java files -&gt; compiler -&gt; class files -&gt; Interpreter -&gt; output 1234567891011121314151617package lab2;/** * Created by emilio on 5/3/17. */public class Rectangle &#123; public int height; public int width; public int getArea()&#123; return height*width; &#125; public int getPerimeter() &#123; return 2*(height+width); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[面向对象程序设计-JAVA 学习笔记01]]></title>
    <url>%2F2017%2F05%2F01%2Fzju-java-notes-01%2F</url>
    <content type="text"><![CDATA[1. 对象交互1.1. 面向对象的设计思想看问题域中包含哪些对象，他们之间的交互行为是怎样的例子：数字时钟 1.2. 关于private,public 私有的含义是对于类而言的，而不是对对象来说私有 若一个对象/函数没有private,public的访问属性限制，则这个东东被视为friendly的，即同一个包内的其他对象可以访问这一个这个成员 1.3. 包 JAVA的类管理是通过文件夹来实现的，简单来说，就是一个文件夹就是一个包，里面的若干个JAVA文件就同属于这个包的。 full name vs. given name 1.4. 类对象和类函数 简单来说，就是加了static修饰符的对象和函数 类对象和类函数只能被同级对象/函数访问，无法被对象变量/对象函数访问]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 0.1. Quick Start0.1.1. Create a new post1$ hexo new "My New Post" More info: Writing 0.1.2. Run server1$ hexo server More info: Server 0.1.3. Generate static files1$ hexo generate More info: Generating 0.1.4. Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
